/*
SQLyog Community Edition- MySQL GUI v6.15 RC2
MySQL - 5.5.33 : Database - blog
*********************************************************************
*/

/*!40101 SET NAMES utf8 */;

/*!40101 SET SQL_MODE=''*/;

create database if not exists `blog`;

USE `blog`;

/*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */;
/*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='NO_AUTO_VALUE_ON_ZERO' */;

/*Table structure for table `article` */

DROP TABLE IF EXISTS `article`;

CREATE TABLE `article` (
  `article_id` int(11) NOT NULL AUTO_INCREMENT,
  `article_name` varchar(255) NOT NULL COMMENT 'article名称',
  `article_url` varchar(255) DEFAULT NULL,
  `article_adddate` datetime NOT NULL,
  `article_moddate` datetime DEFAULT NULL,
  `article_content` blob NOT NULL COMMENT 'article内容',
  `category_uid` varchar(255) NOT NULL,
  `article_uid` varchar(255) NOT NULL,
  PRIMARY KEY (`article_id`)
) ENGINE=InnoDB AUTO_INCREMENT=35 DEFAULT CHARSET=utf8 CHECKSUM=1 DELAY_KEY_WRITE=1 ROW_FORMAT=DYNAMIC;

/*Data for the table `article` */

insert  into `article`(`article_id`,`article_name`,`article_url`,`article_adddate`,`article_moddate`,`article_content`,`category_uid`,`article_uid`) values (1,'要让对的成为赢家','0','2013-08-14 12:55:13','2013-08-14 12:55:13','\r\n    真实虽然是重要的，若就处于升学、就业各种“压力山大”下的学生而言，幻象也许才是更具吸引力、令他们心甘情愿沉湎其中的。\r\n</br>\r\n　　因为茫然，因为焦虑，因为不敢面对真实生活里需要的艰辛打拼，与对未来的不确定性不安全感，亦因为幻象世界里的浪漫、富有、刺激、自我、唯美，这个时代似乎越来越多的年轻人选择屏蔽真实，死守幻城。由于长期生活在经过精致的文字或歌词构筑的理想化世界里，长久不接地气，这些青少年逐渐变得刻板、自负、排他，他们简单而偏执，毫无理性，甚至缺乏基本的常识判断。他们就像被偶像蛊惑与商业狂风劲吹下刮起的满天粉尘，自贱而疯狂，固执又轻信，热情澎湃地充当着“粉丝”书籍、“粉丝”电影、“粉丝”电视剧、“粉丝”演唱会的消费主力军。\r\n</br>\r\n　　如此，你便不难理解为何某公司的一次微博微信调查，竟会显示这样令人瞠目结舌的结果：死活读不下去的前十本书，中国四大名著居然全部上榜。你便会相信中国社科院今年5月发布的“文学蓝皮书”所言不虚：连诺奖引发的“莫言热”也未能改变中国书市的畅销格局—排在畅销榜首的依然是郭敬明。报告主编还声称：不仅图书，中国现有传统文学期刊的全部发行量加在一起，才仅仅能抵上郭敬明旗下5本杂志的发行量。\r\n</br>\r\n　　如此，你便更容易理解，为何从未涉足过电影的郭敬明，随便在银幕上做了个极尽享乐、唤作《小时代》的美梦便能赚大钱：即使故事情节混乱，叙事平庸乏味，逻辑漏洞百出，演员表演矫揉造作，仅因网罗了一批帅哥靓女，展示了一堆普通人遥不可及的奢华物质，搭配上郭敬明式海市蜃楼般空洞绮丽愿景的内心独白，在纸醉金迷中生硬镶嵌点梦想、青春、友谊的花边，营销贩卖给年龄心智均不对等的粉丝族群，烂到这种境界的片子亦能名利双收，观众也能趋之若鹜，票房不断攀高刷新至数亿。\r\n</br>\r\n　　可是，这样的高票房与艺术又有何关系？这年头，只有粉丝才是真正的生产力！\r\n</br>\r\n　　郭敬明导演并编剧的电影《小时代》上映后，最两级的争议似乎来自郭氏粉丝与水军组成的吹捧拔高派，与心智价值观皆正常的观众构成的痛批吐槽派。他们之间的对阵亦将不少好奇的围观者推波助澜送进电影院，顺势助推不断飙升的票房。“郭氏粉”大多是些思想不成熟又自以为是的中学生，或缺乏社会阅历与生活磨炼、刚从校园走入社会的纯真青年，他们对未来与社会充满梦幻，对成功、金钱、名利、各种无敌国际品牌沉迷无匹，喜欢将社会上各类成功人物尊为偶像奉若神明，并视作自家“祖宗八辈”般的亲人誓死“捍卫”。他们对偶像的推崇与赞美几乎没有任何标准与原则，对大众审美与价值取向亦视而不见。偶像的每一部作品他们都毫不例外地夸张高赞，毫不犹豫地掏钱埋单，为偶像财富的进一步聚集不断贡献自己的力量。倘若身边竟有观点分歧意见相左的吐槽者，这些毫无理性的粉丝瞬间便能变成不可思议的狠角色，他们充满情绪地与你激辩抬杠，一言不合，便会发飙开骂，恨不能奋臂攘袖动粗，与你大战三百回合。你若好心告诉他们：那都是些骗小孩子的玩意儿。他们会如美梦被戳破般激烈地冲你嚷嚷：是你自己落伍了，是你们跟不上时代了。你若再作努力与之沟通，逼急了他们会拿出一套奇葩逻辑予以重炮攻击：你们这些“老不死”的是羡慕嫉妒恨，是吃不着葡萄说葡萄酸，是阻碍年轻人上位。有本事你写部《幻城》《左手倒影右手年华》那样的畅销书试试？！你牛逼你拍部《小时代》那样的电影给我们瞧瞧？！你若还不知趣，非要戳到其偶像的痛处：他是个文化剽窃者，他涉嫌抄袭还高调拒不认错，你们为啥非要对这样一个人顶礼膜拜？他们的回答一定是：他抄袭都能这样成功，你们谁有这个本事？\r\n</br>\r\n　　你被吓到了吗？但—这，便是眼下这个商品时代奉献给若干民众的怪异成功学：只选赢的，不选对的。\r\n</br>\r\n　　就像不久前因与默多克离婚，再次成为媒体宠儿的邓文迪，很多渴望成功的女性均视之为优质鸡血—励志偶像。她们的逻辑是：“让一个新闻帝国的国王，那么一把年纪了，还跑去跟老婆离婚，你们谁有这个本事？”“如果你们到了舞会现场，大概腿都会发抖吧，谁还有胆量故意把红酒洒在自己大老板身上？请问你们谁敢？”没有谁去明辨是非对错，仿佛只要成功了，只要成了最后的赢家，肆无忌惮与不择手段均无人在意，赢家便可一次次爆红，并获得万众拥戴。\r\n</br>\r\n　　多么可怕的逻辑！—谁赢了，谁就是对的！\r\n</br>\r\n　　最近美国也有一部展示奢华物质的电影上映。这部2013版的《了不起的盖茨比》，聚集了好莱坞当下最当红的俊男靓女，为了不负时尚大片的职责，更为了展示上世纪20年代纽约挥金如土的生活，导演选择将服装与珠宝走向更为华贵的档次，珠宝由蒂芙尼领头，女装由普拉达装扮，男装由美国大品牌布克兄弟设计。结果恶评如潮，票房更是遭遇了前所未有的滑铁卢。美国民众与影评人均狠批该片被庞大的资本势力绑架，影片毫无审美价值，只是一部被各大品牌瓜分的一部时尚大戏而已，与原作者菲茨杰拉德的用意完全相反。大家都拒绝买票观看。\r\n</br>\r\n　　他们可不想让错的成为赢家！','c0','a1'),(2,'契诃夫——短暂生命所创造的奇迹','0','2013-08-14 10:33:05','2013-08-14 10:33:05','       安东·巴甫洛维奇·契诃夫( 1860～1904) 俄国小说家、戏剧家、十九世纪俄国批判现实主义作家、短篇小说艺术大师。1860年1月29日生于罗斯托夫省塔甘罗格市。祖父是赎身农奴。父亲曾开设杂货铺，1876年破产，全家迁居莫斯科。但契诃夫只身留在塔甘罗格，靠担任家庭教师以维持生计和继续求学。1879年进莫斯科大学医学系。1884年毕业后在兹威尼哥罗德等地行医，广泛接触平民和了解生活，这对他的文学创作有良好影响。他和法国的莫泊桑，美国的欧·亨利 马克·吐温齐名为四大短篇小说巨匠。契诃夫仅仅活了44岁，23岁发表了短篇小说《胖子和瘦子》，进入文学创作领域，塑造出两个世界文学的典型形象：变色龙奥楚蔑洛夫，套中人别里科夫。前者以精湛的艺术手法，塑造了一个专横跋扈、欺下媚上、看风使舵的沙皇专制制度走狗的典型形象，具有广泛的艺术概括性。后者以讽刺手法，入木三分地刻画出沙皇专制制度的忠实卫道士的典型形象。\r\n契诃夫为何能成为文学大师，有很多因素。但以下几条，我们不能不注意。\r\n&nbsp;&nbsp;一、他最初写作，只是“玩玩”，但缺乏自信，甚至不敢署自己的名字，是一位年过六十五岁的老作家在偶然读到他的一篇小说，并被他打动后，富有远见地与他通信，鼓励他，指导他……\r\n</br>\r\n二、安东·契诃夫一生历尽坎坷，他拖家带口，体弱多病，穷困潦倒。然而，他又是勇敢、顽强和勤奋的。\r\n三、他长期行医，广泛地接触了俄罗斯的各个阶层，尤其是下层劳动人民。他26岁已经成名，但是即使在最寒冷的夜里，多病缠身、时无多日的契诃夫，仍去为那些贫苦的农民出诊。\r\n“在全国所有医生当中，我是最不幸的一个：我的车马不顶用；我不识路；我没有钱；晚上，我什么也看不到，很快就会感到疲劳——而最关键的是——我从来都无法忘记自己必须写作，我迫切地希望把霍乱病人送走，让自己能坐下来写作……我的孤独彻头彻尾。”契诃夫在给编辑朋友苏沃林的信中写道。\r\n一面感到厌倦，一面一听到狗叫或有人敲门（一定是找他看病的），就一个哆嗦跳起。这就是契诃夫。\r\n四、契诃夫一直生活和体味着贫穷苦难的下层，他本人穷困潦倒，拖家带口，体弱多病。他把自己的艰辛，别人的苦难用朴实的语言一一道来，没有华丽的词藻。\r\n五、天才的契诃夫在创作过程中并不是一帆风顺的，在19世纪80年代中叶，他写下大量诙谐的小品和幽默的短篇小说，很多是无甚价值的笑料和趣事，但其中也有一些比较优秀的作品，继承俄罗斯文学的民主主义优良传统，针砭当时社会的丑恶现象，如写卑欺强节的小官吏（《在钉子上》、《一个官员的死》、《胜利者的胜利》，均1883），凌辱弱者的士绅和老爷（《英国女子》1883），见风使舵的奴才骨（《变色龙》，1884），专制制度的卫道士（《普里希别叶夫中士》，1885）。但他迫于生计和缺乏经验，在当时主要只求速成和多产。1886年3月，名作家格里戈罗维奇写信要他尊重自己的才华，他深受启发，开始严肃对待创作。写于1886年的《万卡》、《苦恼》和1888年的《渴睡》，表现了作家对穷苦劳动者的深切同情。1888年问世的著名中篇小说《草原》描绘和歌颂了祖国的大自然，思考农民的命运，表达人民对幸福生活的渴望。《命名日》(1888)和《公爵夫人》(1889)等暴露了伪善、爱慕虚荣和庸俗等习气。这些作品在思想内容和艺术技巧方面都有明显进展。但受小资产阶级环境影响的契诃夫在这时不问政治，只“想做一个自由的艺术家”，要有“最最绝对的自由”。他从1886年起为反动文人苏沃林发行的《新时报》撰稿，虽经批评家尼·米哈伊洛夫斯基的劝告，仍同它保持关系。1888年10月，契诃夫获“普希金奖金”半数。这时他已是5部短篇小说集的作者（《梅尔波梅尼的故事》，1884；《五颜六色的故事》，1886；《在昏暗中》，1887；《天真的话》，1887；《短篇小说集》，1888）。声誉和地位的日益增高，使他强烈地意识到自己作为作家的社会责任感，认真地思索人生的目的和创作的意义。他说：“自觉的生活，如果缺乏明确的世界观，就不是生活，而是一种负担，一种可怕的事情。”这种思想形象地表现在中篇小说《没意思的故事》(1889)里。\r\n六、虽然他熟悉生活，但仍然奋力走向自己所不熟悉的领域。1890年4月至12月，体弱的契诃夫不辞长途跋涉，去沙皇政府安置苦役犯和流刑犯的库页岛游历，对那里的所有居民、“将近一万个囚徒和移民”逐一进行调查。库页岛之行提高了他的思想觉悟和创作意境。1891年他在一封信里说：“……如果我是文学家，我就需要生活在人民中间……我至少需要一点点社会生活和政治生活，哪怕很少一点点也好。”他开始觉察到，为《新时报》撰稿所带给他的只是“祸害”，终于在1893年同这家刊物断绝关系。他对俄国的专制制度有了比较深刻的认识，写出了《库页岛》(1893～1894)和《在流放中》(1892)等作品，而最重要的则是震撼人心的《第六病室》(1892)。这部中篇小说控诉监狱一般的沙皇俄国的阴森可怕，也批判了他自己不久前一度醉心的“勿以暴力抗恶”的托尔斯泰主义。列宁读它后受到强烈的感染，说自己“觉得可怕极了”，以致“在房间里待不住”，“觉得自己好象也被关在‘第六病室’里了”。\r\n1904年6月，契诃夫因病情恶化，前往德国巴登维勒治疗，7月15日在那里逝世，遗体运回莫斯科安葬。\r\n七、契诃夫创造了一种风格独特、言简意赅、艺术精湛的抒情心理小说。他截取片段平凡的日常生活，凭借精巧的艺术细节对生活和人物作真实描绘和刻画，从中展示重要的社会内容。这种小说抒情气味浓郁，抒发他对丑恶现实的不满和对美好未来的向往，把褒扬和贬抑、欢悦和痛苦之情融化在作品的形象体系之中。他认为：“天才的姊妹是简练”，“写作的本领就是把写得差的地方删去的本领”。他提倡“客观地”叙述，说“越是客观给人的印象就越深”。他信任读者的想象和理解能力，主张让读者自己从形象体系中琢磨作品的涵义。\r\n今年是契诃夫逝世100周年，从这位伟大作家的身上，我们应该吸取一些什么样的力量，获取一种什么样的精神呢？','c0','a2'),(3,'刘姥姥的吸引力法则','0','2013-08-14 09:28:59','2013-08-14 09:28:59','史上\r\n　　《红楼梦》里的民间草根刘姥姥，是作者笔下一个穿针引线的工具，荣国府人多事杂，“竟如乱麻，并没个头绪可作纲领”，不知道该从何处下笔为好，这是艺术创作的一个路障。曹雪芹没有纠缠在荣国府中，而是从千里之外小小一户人家借力，这户人家成了理清荣国府上下关系的头绪，这个头绪就是刘姥姥。\r\n　　然而，在封建特权社会，渺小卑微如刘姥姥，何以能进入权贵富豪人家，又何以能和权贵富豪人家的巅峰人物积极互动，这当中透视出荣国府高层怎样的心理？且看分析。\r\n　　初入荣国府：\r\n　　王熙凤不敢轻视民间力量\r\n　　《红楼梦》第六回交代，刘姥姥一家人在物质上严重匮乏，她靠着女婿女儿度日，女婿狗儿应该是自耕农，有几亩薄田，温饱很成问题，转眼冬季一到，一家人却无物资过冬。在现有条件下，脱贫看来得靠外力了。男主人狗儿只会喝酒叹气，岳母刘姥姥却似乎天生就懂吸引力法则，她说：“如今咱虽离城住着，终是天子脚下，这长安城中，遍地都是钱，只可惜没人会拿去罢了。”在刘姥姥看来，不要老念叨着自己穷，而是要想着财富的一面。问题是怎样去获得财富呢？\r\n　　刘姥姥给家里人画出了一幅接近财富人家的路线图：从狗儿的祖父出发，狗儿的祖父曾在京城当过一任小官，和王熙凤的祖父套近乎认了同宗。吸引力的源头就在这里，这是远的路线图。近的路线图呢？刘姥姥曾经和王夫人的陪房，贾府田租管家周瑞的老婆，也就是周瑞家的，有过来往。\r\n　　路线图显示着向荣国府靠近的可能性，刘姥姥很有民间智慧，她要把这可能性变成现实性，拿出了莫大的勇气，带着孙子板儿勇往直前，前往荣国府。\r\n　　这是刘姥姥家单方面的愿望，荣国府那边接纳与否？给不给面子？读过《红楼梦》的人都知道，刘姥姥第一次去就受到了贾瑞家的礼貌招待，居然还见到了贾府的高层管理王熙凤，获得了接济。贾府为什么有这种姿态呢？\r\n　　刘姥姥带着孙儿第一次见到周瑞家的，对方却半天才想起来有这么个穷朋友，老半天认出来之后为何还是很礼貌地接待了呢？看书中的交待：“只因昔年他丈夫周瑞争买田地一事，其中多得狗儿之力”。\r\n　　贾府和民间的互动\r\n　　周瑞是替荣国府管理田庄的，而田庄就是荣国府主要的收入来源。《红楼梦》第53回也有交代，荣国府名下一处田庄的管理者乌进孝，来荣国府交租，所交物件有“各种米粮共110000斤多，薪炭33000斤，猪、羊、鹿、獐、狍等牲畜310头、鸡、鸭、鹅、猫共1000只、熊掌、鹿筋、海参、牛舌、蛏干等干货2350斤………”\r\n　　而荣国府其他的经营项目都是亏损的，可见田庄收入是荣国府的生命线。而这条生命线不可能像真金白银锁在家中的柜子里，或者放在钱庄里，它们都是民间的土壤，因此不可能和民间脱节。民间那些看似不起眼的小人物，很可能对荣国府的田庄就有着决定性的影响，例如贾府的田庄管家周瑞就因为田地纠纷，请狗儿帮过忙，狗儿虽然不是什么上得了台面的人物，但关键时候帮贾府吆喝两句，帮着扔两块板砖也好啊。\r\n　　因此，周瑞家的不敢轻视，接待了刘姥姥。而位处高层的二奶奶王熙凤，在根本不了解对方是哪门子亲戚，“连影儿也不知道”的情况下，为何也放下架子接待了刘姥姥呢？其实可以看出王熙凤对民间力量也是不敢忽视的，看她跟刘姥姥的讲话吧：“亲戚们不大走动，都疏远了。知道的呢，说你们厌弃我们，不肯常来。不知道的那起小人，还只当我们眼里没人似的。”聪明的王熙凤，是借刘姥姥这张嘴巴，去向贾府穷亲戚穷乡亲们表态：我们还是在乎你们这些穷亲戚的。\r\n　　刘姥姥拿着二十两银子的救济，欢欢喜喜回去了，在乡里肯定没少说荣国府的好话，而王熙凤在乎的，就是这个口碑。\r\n　　二进荣国府：贾母想要孙辈们接地气\r\n　　经济上实现了小翻身的刘姥姥带着孙子带着土特产上门谢恩。而这次她与荣国府的接触更深入了，居然和高富帅白富美们的老祖宗――贾母，成了好友，成为座上宾。\r\n　　这贾母动的什么心思？《红楼梦》第三十九回交待，贾母刚听说刘姥姥来荣国府时，她的第一个念头就是“正想找个积古的老人家说话儿。”所谓积古，就是民间那些陈年旧事儿。这些积古有什么魅力呢？不但贾母老人家爱听，而且连富三代们也爱听，“彼时宝玉姊妹们也都在这里坐着，他们何曾听过这些话，自觉比那些瞽目先生们说的书还好听。”\r\n　　贾母久处富贵，和民间已经隔膜了，但她早年可能对民间还是有印象的。她将刘姥姥待为座上宾，其实就是想重新接收民间的信息，就是想接地气，要孙辈们也来听，就是想要孙辈们接地气。\r\n　　因此，贾母邀请来自民间的刘姥姥做客，其实就想进行一次接地气的熏陶，也算是一次教育吧。这种地气对于贾府而言，它的魅力在于它的朴素实用，善良敦厚。\r\n　　为白富美心理辅导\r\n　　例如刘姥姥信口开河说乡里一个九十岁的老奶奶因为积善积德，结果喜得孙儿，这种直线条的好人好报方式，贾母听着喜欢，连王夫人听着也喜欢，为什么？\r\n　　贾府富贵已极，上层人物担心的就是富贵能否持久，能否平安，而刘姥姥那种做好事存好念头，就立竿见影有好报的民间行善思维，给了贾府的女性们很大的心理安慰。\r\n　　王熙凤的女儿巧姐身子骨薄弱，易生病，连站在风地里吃块糕点都得病，迷信的王熙凤认为是出生的日子不好。刘姥姥马上给出一个简单的解决方法，干脆取名“巧哥儿”，这样“以毒攻毒，以火攻火”，保证小姑娘“必长命百岁”。\r\n　　其实这个“巧”字是一个心理符号，让王熙凤从心理上获得正能量，民间穷苦百姓祈求改变命运的方式，就这么简单，不用很多程序，是迷信方法中的简便方法，契合了王熙凤做母亲的心理。可以说，刘姥姥成了贾母、王夫人和王熙凤这几位母亲的心理辅导师。\r\n　　这算是王熙凤的一次接地气，而这次接地气给了她很大的帮助，当贾府破败之后，王熙凤的闺女巧姐差点被六亲不认的舅舅推入火坑，就是这位刘姥姥挺身而出，救出了巧姐。王熙凤只是一次小小的善举，却得到拯救女儿的巨大回报，从这里而言，刘姥姥那种做好事马上就有好报的行善思维又是合理的。而刘姥姥胡诌的关于一位美女的精灵砍柴的故事，又大大地启动了贾宝玉怜香惜玉之心，启动了他对民间女子的同情心，居然兴师动众要去找那位精灵的庙宇。\r\n　　别小看刘姥姥这个人物，虽然表面上是大家取笑玩乐的对象，却不知不觉已经成为贵族家庭里的心理辅导师，其方式简单而易操作，市场空间还不小。\r\n　　贾府正在衰败，贾母心里像灯笼一样清楚，她要借刘姥姥这股朴素乐观勤劳忠厚的地气，为泡在富贵中的贾府接入一股新的气息，从民间的智慧中寻找一种温暖，其实也是寻找心理抚慰。\r\n\r\n\r\n\r\n\r\n狄青版“实话实说”\r\n\r\n读国学 长心眼\r\n\r\n　　狄青受命攻侬智高，行日，有因贵近求从行者，青谓之曰：“君欲从青行，此青所求也。然智高小寇，至遣青行，可以知事急矣。从青之士，击贼有功，朝廷有厚赏；若往不能击贼，则军中法重，恐青不能私也。君其思之，愿行，则即奏取君也。”于是无复敢言求从青行者。\r\n\r\n　　明 樊玉冲《智品·狄青》\r\n\r\n　　公元1052年，即宋仁宗皇祐四年，岭南的侬智高起兵反宋，关于这次起兵的背景很复杂，这里就不作交代了，反正南边硝烟突起，给北宋朝廷造成了极大的震动，于是派兵马前去今天的广东广西一带平乱。派遣的主帅是一位名将，他叫狄青。\r\n\r\n　　这虽是一次突然的军事叛乱，但对于想通过军功升职的人而言，却也是一次难得的机会。于是，在狄青领了将印，准备率军南下之际，就有一些追求功名之辈通过北宋权贵和近臣的关系，找到狄青，要求一起前往前线，得到立功机会。\r\n\r\n　　拒绝权贵托付\r\n\r\n　　狄青早就看清楚了这些人没什么军事才能，无非想借这次平叛浑水摸鱼蹭点功劳而已，拒绝他们吗？好像碍于权贵近臣的面子，不好办；接收他们吗？打仗可不是闹着玩的事，倒是这些人成事不足败事有余，耽误了正事那可不行。狄青虽然是武将，却颇有计谋，不只是军事计谋，也有人事计谋。\r\n\r\n　　他动了动心思，如此跟这些人说：“各位老友，你们申请要跟我去前线平叛，这也是狄青我求之不得的好事，我高兴着呢。”在给足这些人面子后，狄青摆出了任务的艰难性，他说：“侬智高虽然是个小寇，但这次居然惊动朝廷派我这样级别的将领亲自去平叛，可见这不是闹着玩的，事情已经很紧急了。”\r\n\r\n　　狄青并没有夸大侬智高起兵的严重性，当时的事实是：侬智高的兵马所向披靡，岭南一带州县的守将“多弃城遁”，并围困广州多达五十多天，还杀死北宋不少将领。当时的狄青已经是名将，在职位上是马军都指挥使，并进入北宋王朝的枢密院，成为枢密副使。派这样高级别的将领，可见事件的严重性，也可见这场战争的风险性。\r\n\r\n　　在摆完事实的严重性之后，狄青又给他们分析此次从军的两种结果：一种是皆大欢喜的局面，如果大家跟随我狄青作战有功，大家顺顺利利立功，又得朝廷厚赏，那就不用说了；但丑话说在后头，如果此番跟随我前去，干不了活，耽误了事，不能够有效地“击贼”，触犯了军法，那就休怪我狄青不客气，我不会因为私情放你们一马，到时候要军法处置的时候，就没什么交情不交情的了。第二种结果，其实是狄青摆出了自己的立场，军法面前，我绝不容私。到时候可别怪我翻脸不认人。\r\n\r\n　　估计那帮人听到这里，心里就已经打起了退堂鼓，趁着这当口，狄青似乎又给他们一个机会，说：“如果在听了我的说明之后，仍然想去的，你们尽管跟我说，我这就跟朝廷打报告请你们随行。”\r\n\r\n　　其实这是让那伙人掂量一下自己是不是从军打仗的料，以及极有可能得到的结果。这帮人也不是傻子，在做了利害比较之后，觉得贪不了什么便宜，于是再也没有谁敢提出要跟狄青南下征战了。狄青后来在广西的昆仑关大破侬智高的军队，为北宋立下军事奇功。\r\n\r\n　　狄青拒绝的艺术就在于，在一团和气的前提下，实话实说，将最差的结果摆出来，让对方看到最不愿意期待的一面，丑话放在好话里说，但又不让好话掩盖丑话。可谓给足了面子，却又泼了冷水。','c1','a3'),(4,'唐朝为什么没有文字狱？','0','2013-07-11 13:59:30','2013-07-11 13:59:30','今春以来，闲暇时我又捧读起《唐诗三百首》来。虽然曾经读过多次，但多是断断续续，所以留下的印象很零散。这次比较完整地通读，感觉自然不一样。常言道诗为心声，诗圣杜甫的诗被历代誉为诗史。其实在我看来诗就是那个时代社会生活的真实反映，可以与同时代的史书互为补充。夜读诗歌从而知道诗歌所反映的社会生活远比史书中记载的要真实得多，也丰富得多。当然这只是我个人的一孔之见，绝没有任何贬低历史学家的意思。如此说来，便有了一个重大的发现，那就是唐朝为什么没有文字狱？\r\n当然我所要说的文字狱，是指没有像明清那样因诗文导致抄家、杀头，甚至诛灭九族之类惨不忍睹的事件发生，而并不是说唐朝就没有因文字而遭贬谪的事情。因为自古以来文责自负，平常间因文字引起误会、责罚也是难免的事情，更何况家天下的时候。正如柏杨先生在《中国人史纲》中所说的“中国每一个王朝几乎都有文字狱，这是极权政治的特色之一……”那样。\r\n粗略读过唐诗，虽然仍有不少因诗文遭贬谪，罢官、降级的事件发生，但是却没有明清时动辄就是抄家、杀头、剖棺剉尸的血腥场面。你说奇怪不奇怪？\r\n唐诗是中国古典文学的高峰，在此以后诗歌便走入了没落，明清更是如此，所以唐诗也就成了不可逾越的高地。不少专家把这种情况归结为盛唐现象，究其原因有三：一是自汉以后，中华大地分裂割据，几百年来没有形成一个强有力的统一政权，虽然这对于普通百姓来说，战火四起，军阀混战，生活艰难。但同时也反映统治者对人们思想的控制相对要弱，这客观上有利于思想的萌芽与自由传播。其二李唐王朝的政权主体——陇西贵族地处汉民族的边远地带，受自汉武帝确立的儒家正统思想为核心的中原文化影响要小得多。思想的相对自由，从而造就了一个盛唐的开放胸襟与气度，八方来朝，祆教、景教、摩尼教相继传入，各种宗教、音乐、舞蹈等文娱活动盛行就是一个明证；三是李唐王朝对诗歌的推崇与重视。上有所好下必甚焉，提升了人们对诗歌的喜爱和对诗人的尊崇。\r\n但我以为最重要的还是开放开明的胸襟与胆识，或者说唐时还没有形成后来一直现在影响人们日常生活的行为规范和道德标准，比如“存天理、灭人欲”、“饿死是小，失节是大”等三纲五常。甚至可以说唐人的容忍度是大一统政权中前无古人，后无来者的。用《红楼梦》中焦大骂贾、荣二府中的纨绔子弟的话来说，那就是“扒灰的扒灰，烧火的烧火”。唐高宗李治纳父亲太宗李世民的妃子武媚娘，进而立为皇后；唐玄宗李隆基迎娶自己的儿媳寿王妃杨玉环，两个老夫少妻爱得死去活来，惊天动地，演绎了一出人间浪漫的爱情悲喜剧，“从此君王不早朝”，大权旁落，险些让山河变色；还有武则天当皇帝时最为宠信的“二张”，就与其女太平公主有着千丝万缕的关系，尤其是张昌宗，原本是太平公主的情人，天平公主先是对其武则天夸赞张昌宗年近弱冠，玉貌雪肤，眉目如画，身体是通体雪艳，瘦不露骨，丰不垂腴。接着悄悄描述床笫之间的旖旎风光：那味道就像南海的鲜荔枝，入口光嫩异常，婉转如人意，使人神飞魄荡。说得武则天心花怒放，于是纳“面如莲花”的张昌宗为男侍。继而引荐其兄张柬之……\r\n没有明清时是才有的条条框框的束缚，诗为心声，于是就有了令后世感叹不已的唐诗。整个唐朝我们也经常看到某某因什么诗歌文章罢官贬职，但却没有听说过哪位由此而抄家杀头、剖棺剉尸。读这些朗朗上口的唐诗，我们仿佛回到了盛唐，感受到了盛唐气象。“仰天大笑出门去，我辈岂是蓬蒿人。”（李白《南陵别儿童入京》）、“……天子呼来不上船，自称臣是酒中仙……”（杜甫《饮中八仙歌》）、“……安能摧眉折腰事权贵，使我不得开心颜！”（李白《梦游天姥吟留别》），如此傲才视物似乎只有唐朝才有。“……边庭流血成海水，武皇开边意未已。君不闻汉家山东二百州，千村万落生荆杞。纵有健妇把锄犁，禾生陇亩无东西。况复秦兵耐苦战，被驱不异犬与鸡……”（杜甫《兵车行》）诗圣杜甫“三吏三别”声声泪字字血力透纸背的诗句和“汉皇重色思倾国，御宇多年求不得……”（白居易《长恨歌》）白乐天开宗明义就直呼其名，更是世间少有。也许有人会说，那说的都是汉皇之事。但仔细琢磨，借汉说唐，指桑骂槐同样让我们替古人担忧，如此大胆不借后果即使放在今天也毫不逊色。\r\n如果说这些还是隔山打牛隔靴搔痒不过瘾曲笔的话，那么“忆昔先皇巡朔方，千乘万骑入咸阳。阴山骄子汗血马，长驱东胡胡走藏。邺城反覆不足怪，关中小儿坏纪纲，张后不乐上为忙。至今今上犹拨乱，劳心焦思补四方。”（杜甫《忆昔二首·其一》、“三月三日天气新，长安水边多丽人……就中云幕椒房亲，赐名大国虢与秦……”（杜甫《丽人行》）、“虢国夫人承主恩，平明骑马入宫门。却嫌脂粉污颜色，淡扫峨眉朝至尊。”（张祜《集灵台·其二》）这可说的是当朝，而且直呼其名。虽然大多说的是后宫佳丽，但那可是至高无上皇帝最宠信的人啊！谁敢冒这么大的胆子，居然说皇帝最宠幸人的不是？可是我们并没有听说诗圣杜甫等人后来怎么样了？\r\n还有“……翩翩两骑来是谁？黄衣使者白衫儿。手把文书口称敕，回车叱牛牵向北。一车炭，千余斤，官使驱将惜不得。半匹红纱一丈绫，系向牛头充炭直。”（白居易《卖炭翁》）、“……宣城太守知不知？一丈毯，千两丝。地不知寒人要暖，少夺人衣作地衣！”（白居易《红线毯》）这同样说的万乘之君皇帝的人啊！再看看以后，还会有这么大胆的诗，而且还没有出现由此性命难保的诗人？可是流传下来的文史典籍至今我们还是没有听说恶毒攻击×××或者给××××××抹黑的说法。\r\n正因为有了相对开放和宽容的空间，所以才有了唐诗至今无法逾越的辉煌。是盛唐的大度开放造就了唐诗，而唐诗也在一定程度把盛唐气象流传了下来。读这些传之后世的唐诗，讽喻之作可以说是唐诗精华中的精华，有叹宫怨的，有叹劳作之苦的，有反战渴求和平的，也有直写老百姓生活艰难的，给我们留下了最宝贵的精神财富。可是这以后呢？虽然也有不少揭露世事之作，但那都是用命换来的。\r\n所以我要说，盛唐之所以为盛唐，唐诗之所以成为难以逾越的高地，二者是有着必然的联系的，而联系的纽带与桥梁那就是开放、开明、大度与宽容（主观还是客观可以忽略不计，只看结果）。\r\n宋也有令后世感叹的宋词，但那同样也是与赵宋王朝重文和开放有关，苏东坡因乌台诗案不断遭贬谪，但并没有性命之忧，而且也只是他本人受到了影响，他的弟弟同样也是一代才子的苏辙仍旧做他的官，但这种情况以后就再也不会有了！\r\n元虽然也是一个大一统的政权，但是存续时间不长，而且被称为元文学代表的“曲”虽然在民间广为流传，但长期以来仍被视为难登大雅之堂，直至几百年后的清末国学大师王国维先生总结出来才引起人们的注意和重视。因此可以忽略不计。\r\n接下来看明清，文人的命运可以说是走了悖时运。柏杨先生在《中国人史纲》中说，朱元璋当政时，杭州府学教授林元亮奏章上有“作则垂宪”，北平府学教授奏章上有“仪则天下”，桂林府学教授蒋质奏章上有“建中作则”，三人皆因奏章中的“则”字江南方言发音与“贼”相同，被朱元璋认为这是在讥讽他当过小偷而被处斩；尉氏县学许元奏章上引用千年前的古文“体乾法坤，藻饰太平”，因法坤与“发髡”、“藻饰”与“早失”音近，被朱元璋认为前者是在讽刺他当过和尚，后者要早失太平而被处斩；印度高僧释来复辞行时谢恩诗中有“殊域及自惭，无德颂陶唐”，同样被朱元璋认为殊就是歹朱，无德是指责明朝没有品德处斩……\r\n记得看央视《百家讲坛》栏目某明史专家转引清康熙皇帝对明成祖朱棣的评价“远迈汉唐”，我就觉得可笑。因为正是这位崇尚武力的皇帝创造了诛灭十族前无古人的血腥场面。同样都是从他人手里抢来的皇帝宝座，唐太宗李世民和明成祖朱棣对待前朝旧臣可以说是泾渭分明。居然说什么“远迈汉唐”你不觉得可笑吗？战功卓越又如何，文治武功又如何，铁蹄铁拳并不能根本解决问题。我看除了杀人如麻以外，并不能代表他有多高明。正如影响西方社会发展和历史进程的并不是亚历山大、查理曼、君士坦丁、拿破仑等穷兵黩武之人，而是古希腊、罗马的灿烂文明与思想以及文艺复兴时期先贤所倡导的“民主、自由、博爱”。\r\n清代文字狱更是登峰造极，不少人广泛赞誉的康乾盛世又是怎么一个惊心动魄的血腥场面呢？据柏杨先生统计，仅发生在所谓的康乾盛世影响较大的文字狱就有22起，其中又以自诩为十全老人，被现在层出不穷的清宫戏演绎成一位慈祥皇阿玛，俨如邻居长者的乾隆皇帝爱新觉罗·弘历时最多，比较著名的有乾隆17年（1753），江西抚州（时称临川）千总卢鲁生假借大学士孙嘉淦上奏劝弘历停止南游，辞意悲痛，全国流传。卢鲁生磔死，两个儿子处斩，受牵连定罪下狱一千余人；乾隆19年（1755年）江西上饶（时称广信）内阁学士胡中藻著《坚磨室诗抄》中有“一把心肠论浊清”之句，被认为居心不良立即处斩；同年满洲正黄旗人广西巡抚与胡中藻唱和，《塞上吟》称蒙古人为胡儿，被认为诋毁同类，下令自杀；乾隆42年（1778年）江苏东台人徐述夔遗著《一柱楼诗》中有“清风不识字，何故乱翻书”、“举杯忽见明天子，且把壶儿挂半边”，被认为是诽谤，徐述夔剖棺剉尸，儿孙和地方官员全部处斩；同年，江苏吴县（时称长州）人曾任礼部尚书沈德潜所著诗集被人发现中有代弘历捉刀之诗，以及有一首吟黑牡丹的诗“夺朱非正色，异种也称王”。还有康熙49年（1711年），安徽桐城人戴名世著《南山集》中引用明末任皇帝朱由榔的年号以及方孝标所著《滇黔记闻》记吴三桂事迹，戴名世寸磔而死，全族屠戮，方孝标虽死但剖棺剉尸，儿孙一律处斩；雍正3年（1726年）浙江海宁人礼部侍郎査嗣庭在江西主持考试时，试题中有“维民所止”被认为故意要去雍正的头，査嗣庭被逼自杀，然后剉尸，所有儿孙一律处斩，家属贬窜极边；雍正7年（1730年）北京白云观老道咒语中有“天地听我主持，鬼神归我驱使”，雍正大怒，被立即斩首；……悲乎，这又是怎样一个康乾盛世啊！     \r\n过去常言秦始皇焚书坑儒，其实在我看来，较之于明清那可真是小巫见大巫，根本不值得一提。因为秦始皇焚书坑儒范围小，多集中在京畿之地，烧毁的又多是六国文史方面的典籍，之所以成为后来历史学家以及文人学者职责的诟病，主要还是因他开了大一统政权一个不好的头。虽然后世这些文字狱都与他没有任何直接关系，但却是在他的影响下发展而来的。究其根本原因还在于他，所以要把历史的板子打在他的身上。\r\n                                    二〇一三年七月十日','c1','a4'),(5,'历史上最喜爱音乐的皇帝 ','0','2013-08-12 11:15:37','2013-08-12 11:15:37','音乐能激发人的斗志，催人奋进，能使人很快进入一个梦寐以求的思想境界。但是，在中国封建帝王中，擅长音乐者确实较少，可称为“家”的则也并不多，唐代玄宗便是当之无愧的一个。\r\n \r\n   唐玄宗李隆基，世称“明皇”。他酷爱音乐的程度，可与近世的音乐大师媲美。他能演奏多种乐器，如琵琶、横笛、羯鼓等，“凡是丝管，必造其妙”，无一不精，令世人所赞叹。\r\n \r\n\r\n\r\n    据文史资料介绍，唐玄宗在一次坐朝时，目光仰视，若有所思，双手按其腹部，手指不停地上下挥动，很久不发一言。退朝后，宦官高力士问唐玄宗是否龙体不会佳，唐玄宗回答道：“菲也，吾昨夜梦游月宫，诸仙娱予以上清之乐，寥亮清越，殆非人间所闻也。酣醉久之，合奏诸乐以送吾归。其曲凄楚动人，杳杳在耳。吾回，以玉笛寻之，尽得之矣。坐朝之际，虎忽遗忘，故怀玉笛，时以手指上下寻之，非不安也。”一个国家的统治者，竟然偷藏玉笛于龙袍，流连忘返于梦中乐思，而不听文武大臣们的朝奏，真是不可思议。正因为唐玄宗如此专心于音乐，才成为封建帝王中的杰出音乐家。\r\n \r\n\r\n \r\n   唐玄宗不但擅长演奏乐器，还是一位多产的作曲家。其作曲手法娴熟、新颖，不拘一格。他一生创造了100多首音乐作品，大部分是难度较大的器乐独奏、合奏曲和大型歌舞曲。历史上的唐玄宗曾创造过“开元盛世”，他的功绩与和杨贵妃之间的爱情同样惹人注目。但是一首耳熟能详的《霓裳羽衣》，更显现出了他在音乐方面的才华。其代表作《霓裳羽衣曲》，生动、形象地描绘了一幅虚幻、飘渺的神仙境界。白居易赞美它“声随风飘，时凝时散，悠扬于竹烟波月之间”，可见，他在艺术上的成就。\r\n \r\n\r\n \r\n   盛唐，是我国封建文化发展的巅峰时期，涌现出的文学家、艺术家，及千古流芳的作品不可胜数。音乐事业的发展如同其他领域一样迅速而猛烈。具体说这一时期在发展民族民间音乐（民歌、说唱音乐、歌舞、戏曲等）、宫廷音乐、音乐教育机构的建立、燕乐艺人的创造与贡献（声乐、器乐、歌舞、散乐、作曲等方面）、乐器的制作、乐曲形式的改革、音乐理论及音乐思想等方面，都取得了辉煌的成就，遥遥地走在了世界各国的前头。音乐艺术的高度发达与兴盛的原因，对于这位达四十四年之久的皇帝唐玄宗来说有着直接关系。\r\n \r\n\r\n \r\n   “玄宗又制新曲四十余，又新制乐谱。”唐玄宗不但十分重视民间音乐的发展，而且又在此基础上吸收了其他新的因素，融合在自己的创作中。创作的数量也非常可观，《羯鼓录》甚至把九十二首竭鼓曲的创作权，全归他所有。唐玄宗的不少音乐作品至今还回响在中外音乐舞台上。\r\n \r\n   “上洞晓音律，由之天纵，凡是丝管必造其妙。”唐玄宗通晓乐理，艺才超人，凡属乐器，他都可以奏出非常美妙的声音。他对乐器的爱好简直如影随形，甚至“座朝之际，虑忽遗忘，故怀玉笛，时以手上下寻之，非不安也。”这位“皇帝”真不愧为“乐迷”了。\r\n \r\n\r\n \r\n   可见，唐朝文化辉煌多姿，音乐不过是其中一个小的分支，但是当时开明的民风和全民性重视音乐，确实为中国传统音乐的发展奠定了坚实的基础。尤其是唐玄宗作为一个君主，喜爱音乐更为整个朝代的音乐发展提供了契机。唐玄宗无疑是历史上最喜爱音乐的皇帝，是一个伟大的杰出音乐家！','c1','a5'),(6,'中共历史上的五次转轨','0','2013-08-13 17:06:23','2013-08-13 17:06:23','嘉宾简介：萧冬连，1950年10月生，湖南省衡东县人，解放军上校。1969年参军，1978-1886年间，先后在南开大学和解放军政治学院主修中国近现代史和经济学。1979年至2000年，在解放军政治学院、国防大学任教。主要研究领域为中共党史和当代中国史。近期出版有新作《国步艰难：中国社会主义路径的五次选择》。\r\n \r\n \r\n \r\n　　一、历史研究应当秉持怎样的立场？\r\n \r\n \r\n　　学术界应当倡导包容精神，平心静气地讨论问题\r\n \r\n　　萧冬连：共识网一直在努力寻求中国问题的共识，这点我很赞同。但是我认为，比寻求共识更迫切的是倡导一种包容精神。第一，当下中国已经是一个价值多元的社会，要在秉持不同理念的人之间寻求共识太不容易，但是应当有起码的尊重他人价值选择的气度，有平等讨论问题的姿态和耐心，有从对方观点中汲取合理因素的智慧。\r\n \r\n　　第二，应当承认人类理性是有局限的。谁也不能认为自己能包打天下，参透了所有中国问题的真谛，掌握了解决所有问题的命门。我自己总有许多思想矛盾，有许多困惑，因此愿意不带前提地阅读各种观点的文章，吸取合理因素，但始终小心避免皈依于某种派。我不相信有解决中国问题的万验灵药，不相信一个处方就可以根本解决中国的问题，更愿意相信历史应当是不断试错改良的过程，只有次优选择，没有最优选择。\r\n \r\n　　第三，表达方式的可接受性。哪怕一个人提出的观点都是正确的，他要让大家接受就必须好好说话，用事实和逻辑来说服受众，而不是带入太多的情绪化。或许有人认为，言词越尖锐越激烈就越有力量，其实恰好相反。所谓\"有理不在声高\"，越是心平气和，越是依据事实和逻辑，就越具有说服力，争取更多的受众。情绪化的言论除了引起相同观点者的狂欢和不同观点者的对骂，是否能说服那些游离于两者之间的多数，是很值得怀疑的。我自己就比较愿意看那些可以对话的文章，对于那些大言炎炎、不由分说的文章下意识地保持距离。我也很关注知识界的左右之争，从中获益不少，但比较欣赏讨论式而不是论战式，因为太知道论战容易走极端了，1960年代的中苏大论战，文革时期的大辩论都是这样。\r\n \r\n　　理性客观对待当代中国史，一味歌功颂德或嬉笑怒骂都不可取\r\n \r\n　　萧冬连：我们说寻求共识难，其中就包括对中国当代史的看法。我相信一百个人有一百个中国当代史，两极化的看法俯拾即是。要么一味地歌功颂德，回避问题，遮蔽真相；要么一概骂倒，不屑于了解历史的复杂性。这两种态度都不可取，都无助于正确地解读历史。当代中国史研究第一位的任务是追寻历史真相，揭示以往由政治宣传所遮蔽的事实；但追寻真相不等于一切都\"反着看\"、\"倒着看\"，最后的判断只能是依据事实。我想要取得起码的共识，最好的办法是对历史有起码的同情理解，首先弄清\"是什么\"和\"为什么\"的问题，着重于发掘历史本身的逻辑，不作过度解读，也不急于作简单的道德价值评判。我写这本书就是秉持这样的学术态度，近3年来，我的绝大部分时间都在阅读和思考，先后看了几千份文件资料，力求每一判断都立于坚实的材料之上，对历史的复杂性始终抱持一种敬畏，不敢嬉笑怒骂，轻薄为文。\r\n \r\n　　我最近出版的新书《国步艰难》的主题是中国社会主义路径的历史演进。我用\"五次选择\"来概括当代史的演进逻辑，即实行新民主主义-仿效苏联模式-追寻赶超之路-发动继续革命-转向改革开放。当然，所谓\"五次选择\"只有相对意义，实质是两个过程，即从走进传统社会主义到走出传统社会主义。在这个过程中，自然离不开对历史人物的个人意志与党内分歧的分析；但我的思考没有停留在这上面，而是试图说明背后起作用的历史的、制度的、观念的因素。我不奢望本书的分析框架能被所有人接受，但可以为大家提供一个讨论的平台。不管你持左派观点还是右派观念，总还是要了解历史真相吧！在这个基础上，各自都可以作自己的判断和反思。\r\n \r\n　　二、\"新民主主义阶段\"的提出及其终止\r\n \r\n　　新民主主义的提出：是一个宣传策略还是认真考虑过的建国构想？\r\n \r\n　　袁训会：您把建国以来的社会实践归结为五次选择，关于这种划分你所依据的标准是什么？\r\n \r\n　　萧冬连：\"社会主义路径的五次选择\"是我提供的一个解读当代中国六十年历史的框架，它为大家提供一个讨论的平台，至于其准确性是可以讨论的。当然,\"五次选择\"也不是凭空想象的，它是根据历史事实概括出来的。对此也有异议，有人认为\"五个阶段\"的区分很老套。但我认为这是最保险的办法，因为历史就是这样走过来的，硬要去另设一个分析框架，用现代人的观念重构历史，主观色彩就太浓了，毕竟决定历史进程的不是现在人的观念，而是当时人的普遍观念。现代人怎么想只能对现在和未来发生影响，不能对历史发生影响。\r\n \r\n　　徐书鸣：有人提出无论是新民主主义还是社会主义，中共都是在模仿苏联模式，因此可以把1957年以前的中共制度建设统称为\"仿效苏联体制\"，对此您怎么回应？\r\n \r\n　　萧冬连：苏联模式也可以划分为两种，新经济政策是一种，斯大林模式是另外一种。按这种分法，可以说新民主主义也是仿效苏联模式，但是仿效的是新经济政策模式而不是斯大林模式。新经济政策是利用商品货币关系，利用市场机制，发展国家资本主义，而不是把所有企业全部国有化，不是以高度集中的计划经济替代市场经济。苏联实行新经济政策后，没坚持几年就放弃了。新经济政策是列宁从军事共产主义往后退一步的产物，为什么要后退？因为军事共产主义体制下到处都在反抗，只得实行退却，但是列宁的退却是策略性的，他说过一段时间后还是要往社会主义发展的，所以斯大林放弃新经济政策，也可以从列宁那里找到根据。\r\n \r\n　　徐书鸣：也有说法认为新民主主义只是一个宣传策略，你怎么看？\r\n \r\n　　萧冬连：从历史事实出发，当时提出经由新民主主义再过渡到社会主义是很认真的，不能说是一种单纯的宣传策略。新民主主义的理论、纲领的形成有一个相当长的过程，它也有自身的理论依据。在这一过程中，列宁的《两个策略》、《左派幼稚病》两本书对毛泽东的影响很大，大革命时期中共内部出现\"一次革命论\"，犯了左的错误，1934年，毛泽东看到了这两本书以后很兴奋，说早点看到就好了，就不会犯那个错误了。按照传统的理论概括，人类社会的发展是一个递进的过程，包括五个社会形态：原始社会-封建社会-资本主义社会-社会主义社会-共产主义社会，这个发展阶段是不能跨越的。列宁也讲过 \"俄国不是资本主义发展太多了而是太少了\"，毛泽东就引用了他这句话。\r\n \r\n　　新民主主义真正成为建国纲领是在七届二中全会前后，从1948年到1949年，中共领导人关于新民主主义的思想已经有了一些变化，首先是新民主主义存在的时间估计缩短了，比较的对象是东欧国家，当时认为中国国家大，国力更落后，所以过渡的时间应该比东欧国家更长一点，大概是三个五年计划，约15-20年的时间。中共确实想搞一段新民主主义，这在《共同纲领》中也得到体现。至少在1951年之前它还基本按照新民主主义这条路子走的。\r\n \r\n　　新民主主义何以提前放弃？\r\n \r\n　　萧冬连：对新民主主义的看法有两种，一种认为它纯粹是一个策略，另外一种则把它过于神化了，认为新民主主义可以作为当下中国的一个选项，主张重启新民主主义。其实新民主主义是回不去的，回去了也不可能持久，因为它本身就是一个过渡性构想。毛泽东说社会主义是目标，新民主主义\"在桥上\"。按当时人对社会主义的理解，新民主主义很难持续到二三十年以后，提前结束反而符合它自身的逻辑。我这里说的不是历史必然性，而是新民主主义构想的内在矛盾性和发展逻辑。\r\n \r\n　　具备什么条件可以结束新民主主义过渡到社会主义呢？当时中共领导层都从两个方面提出问题：一是生产力状况，中国生产力落后，按照苏联经验，工业产值至少要占到百分之三、四十才能过渡，当时中国工业比例只有10%，所以需要几个\"五年计划\"的时间，通过新民主主义的自由企业制度和市场机制来发展工业，为社会主义准备条件；二是民众在思想上对社会主义前途的接受程度。这两个条件是不一样的，前者是确定的，生产力不可能一夜之间就发展上去，它需要一个很长的过程。后者的随意性很大，它完全取决于所谓的\"阶级力量对比\"，而共产党是可以通过动员改变\"阶级力量对比\"的。共产党追求的目标是社会主义和共产主义，新民主主义只是一个变通方案，是一个阶段性政策。基于这种普遍观念，党内不断地冒出来急于向社会主义过渡的情绪，为什么现在要搞一个新民主主义呢？为什么不能马上过渡到社会主义呢？大家都想往前走。因此根本的因素是社会主义理想和新民主主义政策之间的张力。\r\n \r\n　　具体来讲，导致新民主主义提前终止的因素有三：一是对资本主义倾向的担忧。土改以后，农民发家致富，农村出现了新富农，其实主要趋势是中农化而不是富农化。然而许多人担心得到土改好处的农民个人发家致富了，就不愿意再搞社会主义了。这就是所谓\"资本主义自发倾向\"，当时很多材料都反映出这种担忧。尤其是东北和山西两个老区，急于想动摇农民个体私有制的基础。\r\n \r\n　　二是力量对比的变化，或者说是中共对力量对比的估计发生了变化。中共过去估计在新民主主义阶段，私人工商业占很大的比重，实际情况却不是这样。民国时期国家资本、官僚资本占有很大的比重，没收了官僚资本，加上征收外国企业和建国初期的国家投资，这几块被纳入国有企业，截止至1952年，国企资产已经占了国家经济的百分之六十多。虽然在商业方面，私有企业占的比重大一些，但是工业方面国企占的比重很大，私人企业也基本绑在国家计划的战车上了。1950年，打击投资资本，很多工商业遇到经营困难，于是政府调整工商业政策，国家给予加工订货，鼓励部分企业公私合营。当时的目的是帮助私人企业渡过困难，但是后来一看，这种国家资本主义不恰恰是改造私有企业的一个好办法吗？再加上三反、五反以后，资本家在道义上搞得很臭了，当时说资本家\"五毒\"：偷税漏税、行贿受贿、盗窃国家资产等，属实与否？肯定是夸大了，但也不能说完全是无中生有，资本家是唯利是图的，怎么能挣钱就采取哪种手段，政府控制了资源，他肯定要想办法拉拢政府官员。三反、五反之后，国家政策是一打一拉，有的资本家就撑不住了，干脆提出把企业都交给国家，让国家计划他，他们的子女也靠近共产党，甚至要跟家庭划清界线。因此，对资本主义工商业的改造并不困难。\r\n \r\n　　三是优先发展重工业的需要。建国以后中共的目标之一就是工业化，1950年提出搞 \"十年计划经济建设\"，朝鲜战争爆发后确定优先发展重工业。苏联的援助来了一百多个项目，其中大部分是重工业，比如机械工业、原材料、能源以及军事工业等，工业化计划自然偏向于重工业。重工业的发展不可能依靠自由市场经济来调配资源，因为它即耗费资本、资源，又不挣钱，必须实行集中计划经济体制。其实，在新民主主义阶段计划性已经在增强，按照毛的说法，新民主主义不是自由主义的市场经济，它也是一个计划经济。\r\n \r\n　　提前放弃新民主主义：党内存在分歧却没有正面争论\r\n \r\n　　袁训会：您刚才提到了放弃新民主主义的三个原因，除此之外，它跟当时党内高层--特别是毛泽东个人的思想变化--是不是也有很大关系？\r\n \r\n　　萧冬连：当然有关系，而且是决定性的，刚才提到的三个因素恰恰都反映在毛的思想里面。毛泽东提出立即向社会主义过渡以后，党内并没有发生苏联斯大林时期关于发展道路的激烈争论和路线斗争，当时的确有分歧，但是没有正面的争论，只有毛泽东的批评和一些领导人的检讨。\r\n \r\n　　袁训会：为什么中共高层未经激烈争论就达成了一致呢？\r\n \r\n萧冬连：一方面是服从毛的权威，另一方面是党内分歧的性质。中国要过渡到社会主义，而社会主义就是苏联模式，这在高层是有高度共识的。他们的分歧在什么时候、采取什么步骤向社会主义过渡。假如有一个理由支持从现在开始就搞社会主义有好处没坏处，谁都没有理由提出异议。毛泽东找刘少奇谈了一次话，提出资本主义工场手工业同样能够提高生产率，不一定要求技术进步到特定的程度，农业也能通过同样的方式提高生产率，按照薄一波的回忆，毛的这个说法把他们两个（刘少奇和薄一波）说服了。\r\n \r\n新民主主义政策提前放弃的国际因素\r\n \r\n　　徐书鸣：对于中共提早放弃新民主主义有这样一种说法：1953年斯大林去世，此时毛泽东开始产生获得世界无产阶级领导权的念头，因而他更急切地希望能够尽早在中国建成社会主义。您怎么看这种提法？\r\n \r\n　　萧冬连：这个说早了，毛泽东争夺世界无产阶级领导权思想的形成，应该是在1956年苏共二十大以及1957年\"波匈事件\"以后。还有一种说法认为1953年提早放弃新民主主义，决定向社会主义过渡的决策是受到了苏联的压力，这也没有根据。\r\n \r\n　　仿效苏联模式并不是受到苏联的压力，而是中共自己的选择。中共主动要求苏联派遣专家援助中国建设，政府机构的组建、国家计划的编制、工业项目的确定、甚至机关和企事业单位的日常运作都有苏联专家。军队也是如此，大批的苏联军事专家来到中国，这并不意味着是苏联要控制中共的军队，毛泽东也没有这个担心。毕竟斯大林死后，赫鲁晓夫没有这么大的权威，他在个人的气势上始终是低于毛泽东的，毛泽东也没有把他看在眼里。\r\n \r\n　　从毛时代到邓时代，中共道路、政策的选择的确有其国际背景，首先就是冷战。冷战造成了比较恶劣的国际环境，中国在1971年才进入联合国，在这之前被排斥在国际主流社会之外，遭受西方国家的封锁、禁运和孤立--尤其是美国政府的敌视。在这个背景下，毛泽东和中共高层的战略考虑中，国家安全和强国始终成为首要目标。优先发展重工业与当时的国际背景有关系，建国初，中共接收的工业基础基本是轻工业，重工业寥寥无几，钢铁工业更少，连一辆汽车、一架飞机都不能制造，甚至钉子都要用洋钉。在这种情况下，中国选择优先发展重工业在经济上看起来不合理，但从历史看有其合理性。朝鲜战争以后，中国的工业化起步，核心是苏联援助的156个项目，当时中共向苏联要项目，难道要几个食品厂、纺织厂吗？绝对不可能。肯定要汽车、拖拉机、钢铁、军事工业，所以接受苏联援助自然形成重工业优先。\r\n \r\n　　徐书鸣：建国初，因为中共缺乏政权建设经验，只能仿造苏联体制，但当时的行政要员大多是出身于战争年代的军人，习惯于中国自己的管理方式，二者是否会存在冲突？\r\n \r\n　　萧冬连：当然有冲突，而且有过很大的争论。1958年，军队的开展反对教条主义的斗争，刘伯承、肖克、张宗逊等人都被打成了教条主义，这一事件集中反映了学习苏联正规化体制和中共游击作风的冲突。刘伯承等人主张建设正规化、现代化的军队，所谓现代化、正规化也就是学习苏联的建军模式，在此过程中，有些苏联专家自视比较高，导致冲突很多。尽管学习苏联是毛泽东亲自号召的，但在1958年的时候他也感到不满意，不能老是学人家却没有自己的一套东西。所以他就搞出了大跃进和人民公社，将其视为\"自己的东西\"，而1950年代初期基本是\"照搬苏联\"。正因为这样，他格外珍惜\"大跃进\"和\"人民公社\"。\r\n \r\n　　袁训会：它们是毛泽东的\"中国模式\"。\r\n \r\n　　萧冬连：不仅是中国模式，还是社会主义的新模本，他的目标可能不仅想在中国发展这套体制，而且将其推广为所有社会主义国家的榜样。\r\n \r\n　　三、1957年的\"大转向\"：国家政策如何走向激进化？\r\n \r\n　　1957年反右：\"大鸣大放\"到\"引蛇出洞\"的策略转变\r\n \r\n　　徐书鸣：1957年中共政策激进化，政治方面体现为\"整风\"转向\"反右\"，对此有学者提出质疑：中共的高层领导人都是政坛老手，作出\"整风\"决定时应该预料到知识分子会有猛烈的反弹。那他们为何要整风？整风又为何会发展成反右？\r\n \r\n　　萧冬连：关键是对基本形势的判断。波匈事件发生以后，中共中央开了十几次会议，讨论如何防止中国出现类似的问题。会上把波匈事件原因归结为两点：一是阶级斗争不彻底，东欧各地的反革命势力没能肃清，波匈事件就是自食恶果；二是东欧共产党执政能力不行，发展重工业却没解决民生问题，导致老百姓意见很大，加之官僚主义、脱离群众，脱离实际的问题很严重，加剧了政局的不稳。\r\n \r\n　　从这两方面来反思中共自己，毛泽东认为，通过建国以后的一系列运动，中国的反革命势力已经被清理得差不多了，知识分子和民主党派也接受了共产党领导和社会主义。1956年到1957年初他都是这种判断。因此关注的重点是干群关系、党群关系问题，主题是解决人民内部矛盾。怎么解决？就是整风。整风是共产党一贯作法，1957年开门整风，毛泽东希望利用党外知识界和民主人士的批评冲击党内官僚主义。运动起始，他只想来个和风细雨的小民主，但是在上海考察期间，发现对中央整风的号召，党外人士很热情，党内却冷冷清清，针对这种情况，毛泽东主张发动党外人士向共产党提意见，要来个\"大鸣大放\"。\r\n \r\n　　针对毛泽东\"引蛇出洞\"策略的讨论有两种观点：一种认为1956年的\"双百方针\"到1957年整风都是\"引蛇出洞\"，它们都是毛泽东设的局，只为请君入瓮；另一种观点认为\"引蛇出洞\"的策略是1957年夏天才形成的，至于毛泽东事后在党内说这一策略早已有之，只是为了证明他的英明正确。这两种说法哪个更准确呢？从已有的史料来看，我赞同后一种。\r\n \r\n　　然而，毛泽东\"两类矛盾\"的提法实际上已经暗含了\"整风\"转变为\"反右\"的危险了。他把社会矛盾分成两类：人民内部矛盾和敌我矛盾。什么是人民内部矛盾？什么是敌我矛盾？中间有一个巨大的模糊空间，只要批评尖锐起来，随时可以把人民内部矛盾定性为敌我矛盾，一旦如此，处理人民内部矛盾的一系列民主方针都不作数了，重新启用对敌斗争的手段和策略就成为不可避免。反右就是这样发展起来的。其中决定性的环节有三个：\r\n \r\n　　第一个环节是从\"小民主\"到\"大民主\"造成的紧张形势；第二个环节是采取\"引蛇出洞\"的策略；第三个环节是把在高层、知识界的反右推向基层，很多中小学教师、基层干部被划分为右派分子。相比较而言，高层知识分子毕竟还得养起来，因为他名望很高，遭受打击最重的就是这批基层知识分子。\r\n \r\n　　民主党派：是否企图挑战中共的执政地位？\r\n \r\n　　徐书鸣：在整风过程中，一些民主党派人士看到很多知识分子猛烈批判中共，提出要帮助共产党来遏制这种情况，并想借此扩大自己的影响力，甚至是建立本党派的基层组织，这对中共反右的决定是否有影响？\r\n \r\n　　萧冬连：民主党派当时有没有政治企图，这是需要要讨论的。即使有，它也不会是想取代中共，而是要分享一部分政治权力，毕竟民主党派没有挑战中共权威的力量。民主党派倾向于欧美的民主模式，政治上要求权力自然也是从这种民主理念出发的。本来毛泽东想让他们冲击官僚主义，结果越出了毛划定的界线，指向基本的制度。有人批评\"好大喜功、急功近利、轻视过去、迷信将来\"，\"小知识分子领导大知识分子\"，对毛的刺激很大。总的来说，1957年的运动很难算作一场自发的民主运动，它是共产党发动党外人士提意见，在此背景下，各种激烈的意见就出来了。\r\n \r\n　　袁训会：刚才谈到中共对民主党派的态度问题。有材料说，建国前中共内部有一个文件，其中对很多知名的民主党派领袖都作了分类。可以说，中共从一开始就很警惕甚至敌视民主党派人士。\r\n \r\n　　萧冬连：并不是说中共从一开始就敌视民主党派，否则，1949年的联合政府就不可能有两位民主人士出任政务院副总理，20人出任政务委员和部长，最高人民法院院长也由党外人士出任。后来政策收紧，国务院副总理一律由中共党员担任，但是民主党派部长还有十几个。三大改造完成的时候，很多人主张民主党派的任务已经结束了，应该被取消，但是毛泽东、刘少奇要把民主党派纳入社会主义制度中，1956年中共提出\"长期共存、互相监督\"的思想，提倡\"共产党万岁、民主党派万岁\"，是想以利用党外力量来制衡一下党内的官僚主义的，并不仅仅是策略上的选择。\r\n \r\n　　问题的关键是共产党和民主党派相处是否融洽，或者中共对民主党派挑战共产党执政地位的估计，如果估计民主人士对国家政权有所企图，它一下子就会被打下去，1957年就是这么一个状况。这一时期的历史对后来的政治发展影响很大，社会精英受到很重的挫败，这个影响甚至一直延续到现在。\r\n \r\n四、运动治国再起：从\"反思左倾\"到\"文化大革命\"\r\n \r\n　　\"纠左\"与\"反右\"：毛泽东政策让步的底线\r\n \r\n　　袁训会：从庐山会议到文化大革命，中共每一次的政策实施出现严重后果以后，都会有反思左倾的政策调整，但是随着调整措施的落实，政策倾向又会摆回到左倾激进，您认为原因何在？\r\n \r\n　　萧冬连：第一原因是毛泽东。毛泽东以他不可忤逆的意志左右了政治走向，1953年新民主主义的存废、1956年反冒进到1958年的大跃进、1959年庐山会议从纠左到反右倾，1962年从\"全面调整\"到\"阶级斗争\"，每次政策转向都是毛的意志在左右。毛泽东的个人崇拜是历史形成的，它有很广泛的社会基础，当然也与毛在革命年代的历史功绩、地位有关系。另外毛的个人魅力也有影响，浪漫主义的诗词，通今博古的言谈，这些都征服了那些高级干部。\r\n \r\n　　除社会历史原因以外，就是党内斗争。伴随着党内斗争日益激烈，个人崇拜也在走向炽热化。庐山会议前后毛泽东的影响力有个显著的变化，庐山会议之前党内对毛的崇拜占有很重要的位置，庐山会议以后党内--特别是在高层--对毛的畏惧占了很大的比重，因为反右倾一下把几百万的干部打下去了。当时陈云有一个提法：\"逢人只说三分话，不敢全抛一片心\"，反映了当时党内的政治状况。\r\n \r\n　　为什么纠正起来比较困难呢？很重要的一个因素是毛泽东\"不断往前闯\"，所谓社会主义和共产主义的目标对毛有极强的牵引力。按照他的说法就是一个任务完成以后就要提出一个新的任务，否则大家就冷场了，社会主义积极性也就不可能起来了。毛泽东有一个趁热打铁的思想，大跃进、人民公社就是例子，体现出一种双重赶超的战略：一个是在生产力水平上超英赶美；另一个是在社会主义模式上超过苏联，创造一个比苏联更好的社会主义新模式，证明中国可以提前进入共产主义，并给世界做出一个榜样。所以他不允许任何对它们的挑战，否则毛会马上反击。\r\n \r\n　　1959年庐山会议之前的六、七个月时间里，毛泽东一直在纠左，一共搞了六次会议、两次政治会议、一次中央全会，召开庐山会议的本意也是纠左。但他是有底线的，即不能否认大跃进的\"三面红旗\"，纠左是为了继续大跃进，并不是要放弃它。彭德怀与毛泽东矛盾的核心就是这个，当然其中还夹杂着其它的影响因素：比如党内历史恩怨、高层权力斗争，所以彭德怀在庐山会议上一发话，很多人--毛泽东本人和一些高级将领、官员--认为他是在向毛的地位和权威挑战。毛一反击，大家都来维护他，包括刘少奇也出来说：\"群众运动是天然合理的\"、\"与其崇拜彭德怀，不如崇拜毛泽东\"等。刘少奇本来是想继续纠左，他跟胡乔木说除了反右倾以外，是否搞一个继续纠左的文件？但胡乔木不敢跟毛泽东说，后来他跟毛泽东说了，毛泽东说\"有这回事\"？然后就没吭气。实际不仅是刘少奇，恐怕还有很多人是想继续纠左的，但是在毛表态之后就只能一边倒。因为党内不能分裂，毛泽东要大家表态是跟彭德怀走还是跟自己走，如此一来，谁敢跟彭德怀走，当然跟毛泽东走，还要动员彭德怀服从全局、低头做检讨。当时，是非已经不是第一位了，第一位的是维护毛泽东的权威和党内的团结。\r\n \r\n　　徐书鸣：三年自然灾害在党内形成绝大的舆论压力，迫使毛泽东不得不作出让步，也正是因为这一让步是形势所迫的结果，所以在经济形势有所缓和之后，毛泽东迅速踏上了四清，甚至文革的道路，对此您有何评价？\r\n \r\n　　萧冬连：毛的退却当然是形势所迫，但也不完全是被动的。毛泽东在1961年的退却还是认真的，特别是农村政策，他退了四步：第一步是恢复家庭副业和自留地，纠正\"五风\"；第二步是缩小社队规模；第三步是解散公共食堂；第四步是把基本核算单位从大队下放到生产队，这四步对稳定农村形势起了很大作用。但是毛的退却是有底线的，在农村就是生产队为基本核算单位，因为这仍然是集体经济，再退就是包产到户，那就不是集体经济了。后来的政策分歧就在这里，农民想继续退，只有包产到户才能吃饱饭，而且这种想法很普遍。鉴于地方灾情严重，地方干部第一位的任务是救灾，让农民吃饱饭，所以在政策上也就睁一只眼闭一只眼，很多地方都包产到户了，安徽把全省百分之八、九十的农田划为责任田，但是它说是责任田不是包产到户，这里打一个马虎眼，实际就是包产到户。\r\n \r\n　　毛泽东当时认为三年自然灾害之所以会出现，是因为调查研究、上情下达不够，地方的封锁消息使他难以了解情况，因而出现了\"五风\"：强迫命令、瞎指挥、浮夸风、共产风、多吃多占。还有几个大办，如大办养猪场、大办工业等，他认为这是问题的实质，只要纠正了这些问题，并制定一整套方针政策，大跃进、人民公社的总路线就可以走下去。1962年调整超出了毛泽东的底线，不仅农民要求包产到户，党内包括高层很多人也主张包产到户，陈云、邓子恢以及毛的秘书田家英都是这种主张，对此刘少奇没有阻止，等于是默认，邓小平说也是类似的态度。据此，毛泽东认为中央第一线在困难面前政治上动摇了，要解散集体经济搞包产到户，这样会导致两极分化再度出现，国家要走了回头路。\r\n \r\n　　从1961年到1962年，毛泽东对形势的估计与党内其他人有很大分歧。他认为1961年8月庐山会议以后，国家经济已经开始走出低谷了，刘少奇等人却认为困难时期没过去。所以1962年以后，毛泽东对党内情况有两点看法：首先是党内有一股\"黑暗风\"，实际上要否定三面红旗，借此给他施压；其次是\"翻案风\"，具体有两件事，第一是中央统战部提出一个方案，提出对1957年右派分子甄别，这个提案被中央否定了。毛泽东把这件事看得很重，右派自己都没有提出甄别，为什么统战部要提呢？这不就是平反过头吗？第二是彭德怀的\"八万言书\"，彭德怀为什么写\"八万言书\"？因为刘少奇在会上宣布彭德怀不能平反，不是因为他写信提的问题，而是他有个小集团，并里通外国。彭德怀不能参加七千人大会，他听到后很气愤，于是又写了一封信说如果自己被查到里通外国，就甘愿被枪毙，毛泽东认为是彭德怀在翻案。在外交问题上，当时王稼祥是中联部部长，他向中央建议要缓和国际矛盾，不要四面出击、四面树敌，不能光讲民族解放运动，也应该讲和平运动，借此给国内发展争取一个缓和的国际环境。毛泽东认为这是在中国的外交政策上搞修正主义，犯了赫鲁晓夫式的错误，赫鲁晓夫当时提倡\"三和两全\"：全民党、全民国家、和平共处、和平过渡、和平竞赛，中国不能走这条路。这个大背景下，毛泽东心想自己退到二线以后，党内一线已经走偏了方向，特别是刘少奇，他们都已经不大可靠了。\r\n \r\n　　毛泽东为何退居\"二线\"？\r\n \r\n　　徐书鸣：有观点认为毛泽东退居二线是想做太上皇，它是策略性的。\r\n \r\n　　萧冬连：不能把毛退居二线看成一个以退为进的策略。毛泽东不屑于一般的繁琐国事，他的理想是充当精神领袖，研究社会主义重大理论问题，为世界社会主义的发展指明方向，所以他后来说自己不想要\"四个伟大\"，只希望当一个导师。但是，这并不等于他放弃权力，最高权力还在党的手里，由中共中央主席一手掌握，国家主席只是个名义上的位置。毛泽东在中共八大时还说过，要吸取苏联的教训，斯大林没有培养好接班人，马林科夫太软了。他说，应该趁自己在世的时候解决接班人问题。毛泽东的构想是集体接班，他要搞几个副主席、总书记，一旦打起仗来，一颗炸弹不会把中国高层首脑全炸死了，肯定有人来掌握全局。不过，毛对刘少奇的不信任由来已久，在建国初期就对刘少奇有些不满意，政策上也有分歧。让刘少奇当国家主席或者接班人是历史形成的，从延安整风时期开始刘少奇就是二把手。\r\n \r\n　　袁训会：一直以来都是毛泽东对刘少奇不满，但刘少奇似乎没有太多忤逆毛的意思。\r\n \r\n　　萧冬连：对，刘绝对没有挑战毛的意思，他既没有这种想法也没有这个权威。1950年代，无论毛泽东走到哪里都有群众围上去喊\"万岁\"，反观刘少奇1961年去农村做调查的时候，一个支部书记跑到门口骂他\"刘胡子\"，不仅在基层群众中，他在党内高层也没有什么光环。1964年夏天，刘少奇动员大家下基层搞\"四清\"，他放下狠话\"不下去不能当中央委员，不能当候补中央委员\"，高层官员只得听从，但也是怨言颇多。当时几个军队将领散会后就骂娘。\r\n \r\n　　刘少奇是个刻板的领导人，不具有毛泽东的魅力和个人崇拜。当然作为第一线领导人，他掌握实际权力。毛之所以会感觉到大权旁落，原因在于一线干的事情不符合他的心意，他觉得有必要采取措施重新掌握权力。\r\n \r\n　　社会主义路线的分歧：文化大革命发动的国际和国内背景\r\n \r\n　　袁训会：七千人大会以后，中国进入了运动的高发期，直到文化大革命的爆发，您认为这段历史走向的根源在哪？\r\n \r\n　　萧冬连：根源可分为国际和国内两部分：国外因素是中苏论战引发的意识形态冲突，反修、防修成为中共的国策；国内因素是大跃进失败以后的党内分歧。\r\n \r\n　　中苏分裂的原因很复杂，其中既有国家利益的冲突、党际关系的纠葛、两个毗邻大国之间根深蒂固的不信任，也有毛泽东和赫鲁晓夫的个性差异，互相争夺马克思主义和社会主义解释权，争夺国际共产主义领导权等诸多因素。当时中共坚持一种经典意义上的社会主义，苏联、东欧国家则要对社会主义传统模式做一些改良。尽管赫鲁晓夫走得不太远，但是我们认为他们已经走得很远了，苏联、东欧已经走向修正主义了，南斯拉夫搞工人自治和市场社会主义不就是修正主义吗？这场意识形态的论战可以归结为经典社会主义和社会主义改革潮流的一次激辩。\r\n \r\n　　当时对国际反修、中苏论战的问题，党内高层十分亢奋，同仇敌忾。刘少奇做了好几个国际反修的报告；而中苏谈判的主将是邓小平，出访苏联的中共代表团团长大都是他，导致中苏最终走向决裂的1963年中苏谈判，中共代表团团长就是邓小平。 \"九评\"是由邓小平具体主持撰写的，\"九评\"的观点主要来源于毛泽东，但它不能说邓小平的思想与\"九评\"有抵触，邓在中苏论战中上很坚定的。\r\n \r\n　　国内因素是大跃进失败以后，大家都想退，但是退的底线是不一样的。1961年，毛泽东提出要调查研究，他认为大跃进过程中的问题根源就是过去没搞好调查研究。于是全党--从中央到地方--都到农村搞调查研究，刘少奇、周恩来、陈云都到过最底层，其中刘少奇在湖南待了44天，还住过生产队的猪棚，在他的家乡了解情况期间，刘感觉到中共过去的政策的确有问题，必须纠正，否则\"不是路线错误也要走到错误路线上去了\"。\"三分天灾，七分人祸\"就是刘少奇在这一时期提出来的。中共高层有人主张包产到户，是一个策略性举措，一个权宜之计，为了大家吃饱饭，等今后经济形势转好了，可以重新发展集体经济。总而言之，在困难面前，部分中共领导人逐步地放弃了1958年以来狂热的意识形态，向常识理性回归。\r\n \r\n　　当然，不是说所有人都有这种反思，党内还有一些人，包括一些地方大员仍然坚持总路线的思维，总想形势好了继续大跃进，这对毛泽东有影响。从国际反修到国内防修、从四清运动到文化大革命，党内思潮越来越激进。在反修、防修的问题上，中共内部是有共识的，因为反修正主义占据了意识形态的制高点。但在对它的具体理解上还是存在分歧的，比如刘少奇、周恩来就比较强调党内干部腐化变质、官僚主义等问题，毛也强调这点，但是他认为党内高层路线分歧更危险，刘和周基本上不谈1962年的路线分歧。四清运动后期--1964年年底的时候，毛和刘的矛盾表面化了。一些高层领导人要刘尊重毛，动员他给毛做一个检讨，但裂痕难以弥合了，毛泽东已经失去了对刘的信任。我一直不理解刘少奇为什么在四清运动中这么激进，如果是为了迎合毛泽东，那他没必要在很多做法上比毛还\"左\"。\r\n \r\n　　一场预防性的演习：毛泽东与文革的发动\r\n \r\n　　萧冬连：对于毛泽东发动文革的目的是什么，有两种解释体系：一种是纯粹的权力斗争，毛泽东要通过群众运动打倒刘少奇，以解决大权旁落的问题；另一种是意识形态的冲突，毛在追求社会主义的乌托邦目标过程中，遇到了空前的挑战，所以他要通过这种方式来解决这个问题。\r\n \r\n　　我认为毛泽东发动文革的意图是上述两方面的复合体。打倒刘少奇肯定是首要目标，但是他斗争的对象不仅仅是刘，还包括其他党内高层，或者称为党内走资本主义道路当权派。另一方面，毛泽东也把文革视为预防性演习，通过发动群众来解决潜在的危机，让没有经过战争年代考验的青年人在其中锻炼自己，培养出社会主义新人，无产阶级事业接班人。毛认为只有社会主义新人才能建设社会主义，从60年代初期开始学雷锋、学老三篇、学解放军等一系列道德化、政治化运动，到文化大革命的\"神魂深处爆发革命\"、\"狠斗私心一闪念\"。同时，大演习也能让左派、右派以及动摇不定的中间派都暴露出来。最后，文化大革命宣称要建设一个无差别、无等级社会的新模式。然而文革时期混乱不断，体现出来的只有\"破\"，没有\"立\"，事实上也\"立\"不起来。\r\n \r\n　　袁训会：文革的发动与毛泽东和党内权力斗争也有关系，还有一个根本原因是建国以来，中共特别不注重规则、法制，后来就发展成了无法无天的局面，毛泽东个人意志决定一切。\r\n \r\n　　萧冬连：毛时代最大的特点就是运动治国，什么都要靠阶级斗争、群众运动的方式，这个东西可以算作毛的独创，战争年代，中共通过动员民众夺取革命胜利，建国以后它也是依靠这套模式，对规则、对程序则是不屑一顾。毛泽东要求实质民主、直接民主，他的直接民主就是发动群众运动，包括用群众运动来整治官僚主义。\r\n \r\n五、历史的转轨：从拨乱反正到改革开放\r\n \r\n　　改革的启动：\"文革把既得利益阶层给铲平了\"\r\n \r\n　　袁训会：有人认为，文革之所以能结束，不仅仅因为它让整个中国陷入民不聊生、全民灾难，更重要的是官不聊生，以及官员之间互相内斗。\r\n \r\n　　萧冬连：文革虽然是全民运动，但是各个阶层都受到了冲击，党内的干部也不例外，他们在\"打倒一切，全民内战\"中都遭了罪，所以毛一去世，文革不可能再持续下去，党内在否定文革的问题上是高度一致的，但是对前17年的问题，党内认识就不一致了，相当一部分老干部是肯定前17年的。在做历史决议的时候，如何定性前28年中共历史是有分歧的。开始是按时间顺序把前28年写下来，结果是一个运动接一个运动，一个错误接着一个错误，邓小平对此不满意，认为这样就把前28年否定了。后来换一个方式，先写成就，再写经验，再按照历史线索写，这样才把前28年历史定性的难题解决了，否则就变成中共执政绝大部分时间里，它做的事都是错的。\r\n \r\n　　中国为什么能走向改革？关键是文革结束以后，各个阶层--特别是各个精英阶层--都是文革的受害者，文革把过去的既得利益阶层给铲平了，这个与苏联很是不同，苏联体制有很大弊端，但改革却缺乏动力。现在一般讲中国是渐进式改革，苏联是激进式改革，其实是不对的，苏东剧变之前的三波改革潮，都是渐进式改革，但是改不动，其中很重要的原因是它有强大的利益阶层，不只是高层的，基层普通老百姓也怕失去既得利益。苏联集体农庄的社员在1966年的时候就有了劳保。\r\n \r\n　　中国则不同，75%-80%的农民的是不享受基本社会保障的，他们必须自谋生路，所以农民成了包产到户改革的动力。工人相对复杂一点，他们在毛泽东时代的福利保障比较齐全，而且在政治心理上的地位很高，但是80年代改革并没有触动工人的利益，比如破产下岗的问题没触动，所以他就不会成为一个阻力。不仅如此，80年代国有企业的改革采取的放权让利，实际上工人得了利，因为过去企业没有任何钱，不能盖房子也不能解决就业问题，它有了钱以后，可以给职工盖一些房子，解决子女就业。至于官员阶层，基于个人的痛苦经历和对文革的反思，从中央到地方确实出现了一批锐意改革的领导人。\r\n \r\n　　最近诺贝尔经济学得主科斯和他的助手写了一本《变革中国》，提出一个\"边缘革命\"的理论，认为中国走向市场化完全是边缘力量在起作用：包产到户的农民、个体户、乡镇企业，特区，这四个力量推动了中国的市场化转型。他的观点有道理，市场机制一旦被引入，它就会有不断扩张自己疆域的能力，参与市场的主体都是利益驱动，不需要动员，每个人都为发财或者自谋生路不断加入到市场当中，从这个意义上说，确实是来自底层的社会力量推动了中国的改革，但是不能够把底层力量跟高层主导的改革分割开，比如说包产到户，毛泽东时代已经有四次包产到户，最后都搞不成，为什么三中全会以后就搞成了呢？很显然是高层政策变化的结果，高层政策不变的话，包产到户不可能全面推行。农村改革是农民对政策底线的不断冲击，从中央到地方一批官员对农民的同情和支持，以及政策跟进相互作用的结果。所以不能把中国的市场化改革单纯地讲成一个边缘力量的作用，它是一个上下互动的过程。\r\n \r\n　　邓小平与陈云：\"政治上的共识\"和\"改革措施上的分歧\"\r\n \r\n　　徐书鸣：学界有观点把中共改革开放的决策定义为不同阵营之间--比如邓小平阵营跟陈云阵营--斗争的结果。\r\n \r\n　　萧冬连：有人把改革开放看成不同派系斗争的结果，比如\"四派\"：凡是派、还原派、改革派、民主派，或者是两个阵营：邓小平阵营、陈云阵营，这就把问题看简单了。无论邓小平还是陈云，他们在政治上是有共识的，也是互补的，只是在改革措施上有不同的看法。比如对计划和市场的关系，他们有不同的看法。涉及到发展速度的问题，邓小平要求快，陈云认为要平衡，欲速则不达。\r\n \r\n　　在经济改革问题上，也不能说陈云反对改革，其实改革的第一块理论模板就来自于陈云，而且是出自于陈云在1956年八大提出的\"计划经济为主、市场经济为辅\"，在计划经济情况下引进市场机制，实现大集中、小分散，至少1980年以前的改革基本是按这个思路做的，也就是放权让利。陈云的思想并没有变，变的是实践，随着改革实践往前推进，超越了陈云的底线。\r\n \r\n　　邓小平跟陈云不同的地方在于，邓小平的思路更开放，他并没有划定具体的框框，比如发展私有经济要搞到什么程度。他的标准只有一个：有利于生产力发展，只要\"三个有利于\"都可以试。有的人说邓小平在1979年就讲了市场经济，但仔细推敲会发现，1979年11月份他和国外一个记者谈的市场经济实际上就是市场调节，并不是后来讲的市场经济，他的思想也是不断发展的。\r\n \r\n　　中国改革开始的时候并没有一个路线图，没有一个市场经济的目标模式。如果真是提出这样的目标，改革反而推动不了，党内会遇到极大的阻力。正因为是逐步地往后退，改革才得以实现。经济的发展和改革进程已经到了一定程度，它要求有理论上的新解释，以及政策上的新规定。比如所有制问题，开始是发展少量的个体经济作为补充，国有经济是主体，后来说国有经济是主导，随后又说不管国营企业、私营企业还是民营企业，都是社会主义的基本经济制度，它是逐步往后退的，提前退了肯定不行。但是经济构成演变到了一个特定程度仍旧不退的话，中共就难以适应新的经济发展形势。\"三个代表\"也是一样，大量的新阶层出现以后，如果要扩大共产党的执政基础，必须把新阶级、新阶层容纳到共产党里面，这都是顺势而为的事情。\r\n \r\n　　\"中国特色社会主义\"还是\"中国特色资本主义\"？\r\n \r\n　　袁训会：改革开放至今，市场经济发展的步伐越来越快，很多人质疑这还是社会主义吗？分明是中国特色的资本主义。您怎么看这个问题？\r\n \r\n　　萧冬连：关键是如何定义社会主义，如果按照传统的定义，现在肯定与传统社会主义相差很远。不说苏联斯大林模式，现行体制与马克思的经典社会主义的定义也有差别。有人认为《共产党宣言》里讲\"消灭私有制\"是翻译错误，原意应该是\"扬弃私有制\"，不是\"消灭私有制\"。但马克思还使用过\"废除\"、\"剥夺\"等字眼，可见消灭私有制的确是马克思的本意。它有一个推论前提，就是资本主义基本矛盾--社会化大生产和生产资料私有制之间的矛盾--带来的工人的贫困化和周期性经济危机，马克思认为解决这个问题的途径只有一条：消灭私有制，从而解除人们对资本的依赖，以及资本对人的奴役，实现自由人的联合体。他确实把消灭私有制作为实现人的自由解放的出路。从这个意义上来讲，社会主义市场经济制度与经典马克思主义也有很大距离，尽管现在公有制也占了相当一部分，但是它的比例越来越小，最近几年有人说国进民退，也是短期现象，大的趋势还是国退民进，而且主流的思想也是要逐步减少国家对资源的控制，放宽民营资本在各个领域的准入门坎。在西方人的观念里，所谓市场经济就是私有制经济。\r\n \r\n  但是，如果重新定义，社会主义追求的一些基本的价值还应该成为我们的目标，比如说社会的公平、正义、平等。我们应当继续推进市场化改革，但是这个市场化绝对不能是原始资本主义，这一套在西方社会都已经遭到了否定，中国肯定是不能搞，否则很容易引起社会的剧烈震荡。中国的市场经济应该是现代的市场经济，法制条件下的市场经济，它应该是能够兼顾社会公平、正义和自由等各种价值的市场经济，不能再开倒车回到原始资本主义，不然我们一百多年的动荡就白费了。南美就是一个反面教材，它总是在民粹主义和专制主义之间来回震荡。\r\n \r\n　　民粹主义在集体化时代很流行，它的后果是很明显的，现在再搞这套肯定是不行的。但是，也不是说只要是市场的就是合理的。鼓吹丛林法则、赢者通吃，政府官员都追求个人利益最大化，这个社会肯定是混乱的、动荡的，甚至可能走向崩溃，对这点我很忧虑。','c1','a6'),(7,'我现在是这样编程的','0','2013-08-13 15:56:00','2013-08-13 15:56:00','曾经，我试过接到一些需求。一眼带过后，脑袋马上随着高昂的斗志沉溺在代码的世界中 ，马不停蹄地敲着键盘直到最后测试的完成。我从思绪中恢复过来，乍一看自己写的功能，和需求差了十万八千里，我TM都在干嘛？\r\n \r\n　　除此之外，我还见过类似的很好笑的事情。有一个程序员，经理提了需求，然后他在那里折腾了一天。结果不但没做出来，而且和实际需求都是完全搭不上调。经过询问发现，他不知道经理说了什么，也不知道自己到底在做什么。\r\n \r\n　　代码的世界可能是昏天暗地的，但是我们的思维不能这样随之混乱，否则一切都会前功尽弃。所以我现在编写程序的时候，经常会想一下：我要做什么，我在做什么。更好的方法是把详细需求落实到文档，并时刻核对文档。\r\n \r\n　　大局为重\r\n \r\n　　2-8法则告诉我们，一个项目核心的功能只有很少，其它大部分都是对核心功能辅助或增强的。但当任务分发下来，我手头总有一些自己很想开发的模块，不过它们不属于那20%。我以前经常会在这些感兴趣的模块上花费很多时间和精力。\r\n \r\n　　结果项目快要到上线期限，主要的功能却没开发完成，其它一些不起眼的功能却做得很好，但为此项目不得不延期了。如果反过来，只要对整体功能预期不会有太大偏差，可以将就的先上线。重要一点是：即使功能还有遗漏，但项目可以上线了，老板自然不会太追究，自己工作也能图个安心。如果不知道那些功能模块是最重要的，先问问经理。\r\n \r\n　　人总是喜欢做一些自己感兴趣或者有挑战的事。不过在这方面，为了项目和团队着想，应该尽量压制这种诱惑。\r\n \r\n　　性能永远不是优先考虑的问题\r\n \r\n　　我从来不会一开始就考虑性能问题。如果项目成本很低，甚至到项目结束时，如果没有感觉到明显的性能问题，也不会去管。要知道现在已经不是DOS的年代，CPU的计算能力很高，但成本很低了。重要一点是，如果只针对提升性能对代码做改动，很容易破坏代码的复用性和可维护性。而返过来，提高了代码的复用性和可维护性，则很容易提高性能。\r\n \r\n　　下面有一个PHP的代码实例，功能是帮助用户重置密码（代码为了简单说明问题，请不要太在意一些无关的细节）\r\n \r\n　　requestResetPassword是接收用户重置密码的请求并且做了相应的检查。为了更好的复用性，我将重置密码的操作单独分配到一个新的resetPassword的函数，更改完密码的后再调用sendEmail向用户发送一封通知邮件。\r\n \r\n01    /**\r\n02     * 用户请求重置密码的接收器\r\n03     */\r\n04    function requestResetPassword() {\r\n05        //检查用户是否存在\r\n06        if( !checkUserExists( $_GET[\'userid\'] ) ) {\r\n07            exit(\'抱歉，用户不存在，请确认用户帐号。\');\r\n08        }\r\n09        resetPassword( $_GET[\'userid\'] );\r\n10        //最后向用户发送一封邮件\r\n11        sendEmail( $_GET[\'userid\'], \'重置密码成功\', \'新的密码是xxxx\' );\r\n12        exit(\'新密码已经发送到你的邮箱。\');\r\n13    }\r\n14     \r\n15     \r\n16    /**\r\n17     * 帮助用户重置密码\r\n18     */\r\n19    function resetPassword( $userid ) {\r\n20        //检查用户是否存在\r\n21        if( !checkUserExists( $userid ) ) {\r\n22            return false;\r\n23        }\r\n24     \r\n25        //进行重置用户密码的操作\r\n26        //略...\r\n27        return true;\r\n28    }\r\n29     \r\n30     \r\n31    /**\r\n32     * 向用户发送一封邮件\r\n33     */\r\n34    function sendEmail( $userid, $title, $content ) {\r\n35        //检查用户是否存在\r\n36        if( !checkUserExists( $userid ) ) {\r\n37            return false;\r\n38        }\r\n39     \r\n40        //发送邮件操作\r\n41        //略...\r\n42        return true;\r\n43    }\r\n44     \r\n45     \r\n46    /**\r\n47     * 检查某个用户是否存在\r\n48     */\r\n49    function checkUserExists( $userid ) {\r\n50        $user = getUserInfo( $userid );\r\n51        return !empty( $user );\r\n52    }\r\n53     \r\n54     \r\n55    /**\r\n56     * 获取某个用户的数据\r\n57     */\r\n58    function getUserInfo( $userid ) {\r\n59        //假设我有一个query的函数，它用来查询数据库并返回数据\r\n60        $user = query( \"SELECT * FROM `user` WHERE `uid`=\" . intval( $userid ) );\r\n61        return is_array( $user ) ? $user : array() ;\r\n62    } \r\n　　现在问题是，这三个函数都同时使用checkUserExists这个函数来检查用户不存在，数据库查询了三次，这样带来了一些额外的开销。\r\n \r\n　　如果要去掉三者之间任意一个checkUserExists，看上去是可能的。但是如果之后有某些功能要调用resetPassword或者sendEmail，用户不存在时，系统可能会发生错误。\r\n \r\n　　还有一个解决方法是，将resetPassword的逻辑写到requestResetPassword里，再过一点，把sendEmail的逻辑也写进去。这样函数调用减少，数据库查询也变成一次了，性能得到了提高。但是重置密码和发送邮件的功能将不能得到复用，并且违背了单一责任的原则，代码复杂度也提高了。\r\n \r\n　　不过，因为函数分离和复用性都很好，如果实际性能受到影响，可能考虑用缓存的方法减少数据库查询，我改动了它们共用的checkUserExists函数：\r\n \r\n01    /**\r\n02     * 检查某个用户是否存在\r\n03     */\r\n04    function checkUserExists( $userid ) {\r\n05        //增加一个缓存，用以记录检查用户的结果\r\n06        static $cache = array();\r\n07     \r\n08        //检查当前用户是否已经检查过一次\r\n09        if( isset( $cache[ $userid ] ) ) {\r\n10            return $cache[ $userid ];\r\n11        }\r\n12     \r\n13        $user = getUserInfo( $userid );\r\n14        //把结果记录到缓存中\r\n15        $cache[ $userid ] = !empty( $user );\r\n16     \r\n17        return $cache[ $userid ];\r\n18    } \r\n　　也可以用同样的方法改动getUserInfo函数。\r\n \r\n　　这里可以看到，当代码的复用性提高时，想提高性能是很简单的，性能的瓶颈也很容易被发现和修改。\r\n \r\n　　尽管这个例子对性能影响还不够大，还有一些影响更大的，比如说遍历，我可能为了复用而将遍历封装到一个函数中，并且多次使用它。这些开销对我的项目根本没有预想中那样有太大的影响，或者说是微乎其微的。所以我更愿意把时间花在如何提高代码的复用性和维护性方面，而不是纠结于浪费多这一点性能。实际性能如果真的达不到要求，也可以权衡增加硬件配置。\r\n \r\n　　名字长一点好\r\n \r\n　　函数名和变量名等除了给机器看，也要给人看的，有时一个简单直接的好名字实在是很难想，这时不妨用长一点的名字更好。可读性更好：\r\n \r\n01    //好名字\r\n02    class ErasedTypeEquivalence {\r\n03    }\r\n04     \r\n05    //坏名字\r\n06    class ErdTypeEqe {\r\n07    }\r\n08     \r\n09    //好名字\r\n10    function checkUserExists () {\r\n11    }\r\n12     \r\n13    //坏名字\r\n14    function ckUserExt() {\r\n15    }\r\n16     \r\n17    //好名字\r\n18    $result;\r\n19     \r\n20    //坏名字\r\n21    $ret; \r\n　　我见过一些代码，由于简单写过多，整遍代码很多都是4个字母或以下的，可读性非常差，当然不排除是为了偷懒。\r\n \r\n　　但如果想有更多的时间腾出来偷懒，不应该在这上面玩小聪明，否则这时我现在应该在思考前几天的代码是在写什么。\r\n \r\n　　什么？短名字会让代码执行得更快？ 那证明给我看，如果真的快，快了多少？\r\n \r\n　　自说明代码很重要，但注释同样重要\r\n \r\n　　代码本身可以说明问题的确是很棒的，但并不是说注释不重要，有时候我更喜欢先看注释，因为它总比我看代码更快的了解这程序是做什么的。\r\n \r\n　　如果我把本文前面说性能的例子去掉注释，哪个能让你更快了解代码的意图？或者说，你更愿意看哪个？\r\n \r\n01    function requestResetPassword() {\r\n02        if( !checkUserExists( $_GET[\'userid\'] ) ) {\r\n03            exit(\'抱歉，用户不存在，请确认用户帐号。\');\r\n04        }\r\n05        resetPassword( $_GET[\'userid\'] );\r\n06        sendEmail( $_GET[\'userid\'], \'重置密码成功\', \'新的密码是xxxx\' );\r\n07        exit(\'新密码已经发送到你的邮箱。\');\r\n08    }\r\n09     \r\n10     \r\n11    function resetPassword( $userid ) {\r\n12        if( !checkUserExists( $userid ) ) {\r\n13            return false;\r\n14        }\r\n15     \r\n16        //进行重置用户密码的操作\r\n17        //略...\r\n18        return true;\r\n19    }\r\n20     \r\n21     \r\n22    function sendEmail( $userid, $title, $content ) {\r\n23        if( !checkUserExists( $userid ) ) {\r\n24            return false;\r\n25        }\r\n26     \r\n27        //发送邮件操作\r\n28        //略...\r\n29        return true;\r\n30    }\r\n31     \r\n32     \r\n33    function checkUserExists( $userid ) {\r\n34        static $cache = array();\r\n35     \r\n36        if( isset( $cache[ $userid ] ) ) {\r\n37            return $cache[ $userid ];\r\n38        }\r\n39     \r\n40        $user = getUserInfo( $userid );\r\n41        $cache[ $userid ] = !empty( $user );\r\n42     \r\n43        return $cache[ $userid ];\r\n44    }\r\n45     \r\n46     \r\n47    function getUserInfo( $userid ) {\r\n48        $user = query( \"SELECT * FROM `user` WHERE `uid`=\" . intval( $userid ) );\r\n49        return is_array( $user ) ? $user : array() ;\r\n50    } \r\n　　所以，即使代码本身很清晰，但是加上注释的话，可读性也能提高很多！\r\n \r\n　　适当抽象\r\n \r\n　　编程就是为了解决实际中的问题，在思考如何编码的时候，把问题抽象到一定的高度去思考，更容易把握问题所在。不过更多时候，我发现从代码抽象到现实的例子是有一定难度的，同时我也相信，编程高手也是抽象高手，他们很容易把问题反映到真实生活中去。\r\n一致性\r\n \r\n　　团队开发中，可能每个人的编程风格都不一样，拿花括号来说，有些人喜欢和代码在同一行，而有些喜欢独自一行\r\n \r\n1    //例一\r\n2    function func() {\r\n3    }\r\n4     \r\n5    //例二\r\n6    function func()\r\n7    {\r\n8    } \r\n　　命名风格也都不一样，比如说声明变量接收一个函数返回的数据，有些喜欢用result，有些喜欢用data。\r\n \r\n　　它们可能都很好，不过在团队开发中，尽量统一用同一种风格能够很好的减少交叉开发的成本。\r\n \r\n　　将错就错\r\n \r\n　　面对项目一些无关紧要的分歧或错误，应该要接受和理解。承接上面的问题，如果团队中已经有人大量用了data的变量命名，但你认为result的更符合当前状况的描述。这种情况，我优先选择data命名，因为如果再使用result的话，会破坏项目的一致性，对开发没有任何好处。\r\n \r\n　　这只是很少的一方面，如果项目规范没有很好的落实，实际工作中会有大量的一致性问题，必须靠团队每个人的决心和责任心去把它做好。通常，加入一个正在开发中的项目，编写功能前，我都会首先看项目之前的类似的代码，并尽量模仿他们的写法。不过，如果有明显的错误，应该及时指出和修正。\r\n \r\n　　只要坚持把一致性做好，很多方法会成为团队甚至业界的标准，即使它们不是最好的，但是有什么关系呢？\r\n \r\n　　质量至上\r\n \r\n　　现在还有人认为把时间花在提高代码质量上会降低开发进度。如果你有开发一个长期项目，最后花在修BUG的时间占整个项目的比例是多少？一个质量把握不好的项目，修BUG的时间可能占项目50%甚至更多。如果有兴趣，或者可以看一看这篇文章《不要再问效率还是质量的伪命题》的观点，如果还不够说服力，《人月神话》《代码大全》这两本关于项目管理的书，里面有详细说明这个问题。\r\n \r\n　　适当休息\r\n \r\n　　编程的时候如果没有思路或者感到混乱，到外边休息10分钟，或者看一下风景，让脑袋清醒一下是很好的。这招很管用，亲测。\r\n \r\n　　至少把代码完整运行一次\r\n \r\n　　有时函数的逻辑过于简单，以至于会认为这个不可能发生错误，但事实上最容易发生错误的通常就是这些代码，常见的单词拼写错误，参数错误，还有一些意料之外的问题。所以无论什么情况，我都会把代码完整运行一遍。\r\n \r\n　　当然更好的做法是用一些系统的测试方法，比如说单元测试。\r\n \r\n　　编程不是艺术\r\n \r\n　　从一开始，编程语言的出现和发展，都是为了解决现实生活中的问题，包括它自身产生的问题。\r\n \r\n　　面向对象、设计模式的出现，是用来解决编程语言自身带来的可读性和维护性等问题，而不是为了让编程语言上升到艺术的层面。尽管编程中有‘优雅’一词，但我更认为它只是用来形容代码更容易让人读懂和维护。\r\n \r\n　　我拒绝一切看起来很‘优雅’，却不能为编程工作带来一点好处的代码。如果你喜欢玩弄语言，应该去当作家。\r\n \r\n　　甘于平凡\r\n \r\n　　程序员真的很高傲，在我接触过的人中，包括我自己也是。我以前经常对一些简单的代码感到不屑，而总想在项目中写一些犀利的代码，让人看起来很NB，但结果总是和想象差太远，代码总是写的很差，逻辑也不够清晰。归根到底，是我带着这样的思想去写代码，而忽略了编程的根本：解决问题。现在我改掉了这个坏毛病，以解决问题为目的去编程，以简单为主。出乎意料的是别人有时会对我说，这里的代码写得很棒。\r\n \r\n　　踏实的做事，会有意想不到的收获。\r\n　有原则，有决心\r\n \r\n　　做任何事情都坚持原则，并有决心是最好的。有很多道理我们都明白，但经常做不到，没有任何人能帮到自己，未来也是自己争取的。\r\n \r\n　　所以，如果知道什么是好，就尽量去做，什么是不好，就尽量避免。\r\n \r\n　　即使是在公司面对经理和领导，也要坚持自己的做法，一些不合理的需求应该指出或拒绝。我还年轻，大不了换一家公司，而不愿意做一个受欺压的码农。\r\n \r\n　　我在做什么\r\n \r\n　　文章写完了，现在来回想一下，我是在分享自己现在编程的一些习惯，总算没偏离开始的主题。本文的思想都是来自实际工作和一些书籍，想了解更多的话，推荐阅读《整洁代码之道》《代码大全》《重构》这几本书。\r\n \r\n　　如果你有一些认为好的编程方法，不妨拿出来和大家分享一下。\r\n','c2','a7'),(8,'两程序员不同境遇：少抱怨 多解决问题','0','2013-08-03 11:42:00','2013-08-03 11:42:00','很久以前有两个程序，当时的水准都差不多，现在A是上市公司的技术总监，B还在不停的跳槽，反反复复在“小团队主程”和“大公司打杂”的两种岗位之间不停切换。B一直把这些不同归咎于自己没有遇到A那样子的机遇，经常在群里和微博抱怨自己的运气。\r\n \r\n　　那天我终于忍不住了，在他再一次抱怨之后，我开始喷他，我说你就从来没有想过自己的原因么？同样是一个临时小活动，我叫A做的时候，A都会告诉我，他手上现在有什么，大概多久能做完，做完之后就可以做这个活动了。而你永远都是说现在很忙，什么时候做不完不知道，因为总有不可预知的东西，我们这些外行人问时间掐进度都是很愚蠢的。\r\n \r\n　　同样在计算自己的开发时间的时候，A说三天做完就一定要三天做完，做不完的就会周六周日来加班，你说一周做完的工作能拖一个月，而且拖欠那么多工作还永远觉得无所谓，永远准时 6 点走人，质问你的时候，你还振振有词说没人付你加班费。\r\n \r\n　　同样是手上的工作做完了，A会找我问有没有后继的工作，而你只会浪费贷款在那边看肥皂剧，直到有人发现你为止。\r\n \r\n　　同样是大家吃完饭回来，A会立刻开始工作，你会一定要把剩下的午餐时间拿来玩一把游戏，逛一下淘宝。\r\n \r\n　　同样是 QA 反馈问题，A会第一时间走到 QA 电脑前看具体表现，自己来找问题。你只会说“我不知道”，“我没办法”，“怎么可能”，“你看错了”，“你叫别人做吧”。\r\n \r\n　　同样是主美觉得界面上的画面有出入，A要么到主美电脑前问具体原因，要么一副虚心学习的样子把主美拉到自己的电脑前讲解。你呢？你只会抱怨“早干嘛去了？”“早又不说”“这没差多少啊”\r\n \r\n　　项目结项的时候，项目经理专门给A写了一封上千字的手写推荐信，还推荐A去 TX，你觉得这个机遇对A很重要，你没有得到项目经理的推荐，很不公平。难道你真的觉得是项目经理心血来潮随机抽几个人来写的么？你真的没有意识到，如果把你推荐到那些大团队去，推荐人的脸会被你丢光么?\r\n \r\n　　你完全没有明白什么叫团队，什么叫态度。不是坐在一起就叫团队，不是不吵架就叫态度。\r\n \r\n　　你的思想里面永远是——我拿这一点的薪水，那我只要做这一点的努力就好了。而A一直都是我现在只有这一点的薪水，但是我只要能多干额外的工作，早晚会有人给我更多的薪水。\r\n \r\n　　是的，也许你的做法在你看来是完全正确的，你觉得你没有亏欠任何人，是别人没有给你机会给你平台，但是你完全没有想过——既然A这样的任劳任怨，努力学习的人在市场上，而且机会的总量又是有限的，那怎么可能会有人把机会给你而不给A呢？\r\n \r\n　　所以你现在是你，A现在是A，没有什么好抱怨的。\r\n','c2','a8'),(9,'关于“兴趣爱好”之我见','0','2013-07-27 13:35:00','2013-07-27 13:35:00','人们常说，兴趣是最好的老师，只有感兴趣，才能把事情做好。听起来是挺有道理，但我们仔细去思考，兴趣与把事做好的关系，还是有很多细节值得探讨的地方。（注：这里兴趣指由爱好而产生的愉快情绪，特指对某技能、专业、工作的爱好。）\r\n \r\n　　到底是因为有兴趣才能做好事情，还是因为做得好事情，所以会有兴趣一直去做？二者还真是有点先有鸡还是先有蛋的味道。\r\n \r\n　　我们一般的理解，如果对一件事不感兴趣，强迫自己去做通常是很痛苦的。比如你不喜欢数学，但由于从小到大，它都是主科，特别高考，往往数学成绩决定了最终的排名，所以……所以你必须硬着头皮去学、去做题、去考试。考试分数不佳，挫折感很强烈，对数学更加没兴趣。可是，为了自己的将来，还是不得不打开那满是红叉的试卷，开始苦闷的订正。人生不如意莫过于此，不感兴趣也做不好它却还要不断坚持。把数学作为所有专业方向主科的那位规则制定者，对于那些不喜欢数学的人来讲，是多么的不近人情啊！\r\n \r\n　　另一方面，我们做得好的事情，通常都会对其感兴趣。比如你因为儿时学会了游泳，于是你就一直比较喜欢游泳。你对因为初学打麻将赢了几把，于是之后你经常喜欢找人玩麻将等等。由于你在某方面做得还不错，因此会一直不断关注它、学习它、练习它，之后就玩得越来越好，形成了良性循环。\r\n \r\n　　现在的核心问题，兴趣是如何产生的？\r\n \r\n　　我们在第一次接触一件新技能，比如学习游泳。可能是主动自愿、可能是父母逼迫、可能是巧合遇上，总之，对于此事完全白纸的我们来说，不会带有太大的成见，无论是否喜欢大多都不会有强烈的情绪（少部分“一见钟情”的我们另谈）。\r\n \r\n　　我们开始尝试它。至少要下到水里去扑腾几下。旁边也许有家人、朋友或老师指点，你开始学着闷水，开始感受浮力，开始手划脚蹬。期间不小心呛到几口水，甚至体验到沉下水底差点淹死的感觉等等。\r\n \r\n　　然后，经历了一段时间练习，你有点学会了游泳或者依然不断呛水没有学会游泳。此时，前者就会对游泳产生了强烈的兴趣，而后者则对游泳失去了兴趣。接下来就很简单了，前者会越来越好，后者依然不会游泳。前者会在今后的很多年里对别人说：我对游泳很感兴趣，喜欢游泳。哪怕游泳依然是菜鸟级别。而后者……可能很少会再次下水。\r\n \r\n　　到底是因为对游泳天生感兴趣，才学会了游泳，还是因为学会了游泳，所以对游泳产生了兴趣呢？我认为两者都不是兴趣产生的问题核心。\r\n \r\n　　理论上，一个正常人经过合理练习就一定可以学会很多人都能掌握的游泳技能。之所以最终导致有人喜欢有人不喜欢。问题出在了初学的过程中。\r\n \r\n　　当一个人从第一次接触一件事到入门初步掌握这件事，这个过程的体验好坏决定了对此事的兴趣多少。也就是说，不管你学习任何一项技能，选择任何一种专业，从事任何一个工作，如果你在刚接触的时候可以比较顺利达到入门，体验到些许成就感，那么你就会对它感兴趣，甚至越来越有兴趣，也越学越好。反之，初学体验不佳将直接导致兴趣丧失。\r\n \r\n　　所以我认为，绝大多数兴趣不是天生的，兴趣有无取决于初体验。如果这样理解那么解决办法就很好想了。那就是尽量让初体验不那么困难，挫败感不那么强烈。比如有一个极具教学经验的老师或教练来帮助你入门，找非常适合入门的图书视频或软件来学习，以及在这个过程中有亲朋好友在旁边鼓励加油。\r\n \r\n　　回到本文前面讲学习数学的例子。如果小朋友的家长或者小学低年级时的数学老师可以给孩子足够的趣味引导和鼓励，让他能够相对容易的理解算术的概念、克服数学恐惧并且能够取得一定成绩，考过几次90分以上。那么之后的数学学习就不至于那么艰难，情绪上也不会造成学不好，所以不感兴趣，进而更加学不好的恶性循环。\r\n \r\n　　那么，兴趣有没有可能与生俱来？也就是说，对某个技能可以从没接触而就一见钟情，并游刃有余。我个人觉得，天赋这东西应该是存在的，即不用学或者稍微学习，就能把某种事情做得好到超过大多数人。如个别人天生具有的音乐、数学、运动上的天赋。\r\n \r\n　　但追根溯源，这些天赋总是与幼儿时的某种环境有联系。例如音乐世家的孩子容易出音乐天才，小时候数学好的人很容易喜欢上编程等。不过，假如某孩子天生特别喜欢画画，但父母却不给他任何涂鸦的机会，或者对他要求特别高，画得不满意就破口大骂，那么他将来就很难在画画上有所发展。也就是说，即使存在某种技能上的天赋，如果初学体验不佳，也会造成兴趣丧失，进而技能天赋丧失。\r\n \r\n　　总之，在接触学习时，有了一些辅助条件的帮助，让初体验感觉不错，那么我相信让自己对某事产生兴趣，并持续爱好它，就变得比较容易了。\r\n \r\n　　本文起因是我和朋友聊天，谈到这个话题，引入了我很多的思考，所以专门写作成文，文章并非仅针对程序员。\r\n \r\n　　但对于程序员来讲，道理是一样的。我相信爱好编写程序的人，通常程序写得都不会太差。反过来，写得好的人，通常也都是喜欢编程的人。但有不少朋友极有可能是高中填报专业选择了软件编程这个相对热门的专业，真正进入后，才发现，对这个专业不感兴趣，于是学习起来很痛苦。\r\n \r\n　　其实之所以这样，根本原因就在于，国内的大学在设计编程课程时，可能都是从C语言、计算机原理、数据结构与算法等相对抽象、相对难的课程入手，这个设置并没有太大问题，这些基础对编程来说至关重要，只是在学习梯度上没有做好铺垫，使得入门门槛过高（传说欧美的中学生就引入了很多趣味的编程实践，以便于上大学后可以系统地学习理论，我们国家的大学教育少了这要的步骤）。这个时候如果碰不到一个好的老师或者师兄，自己也没有足够心理准备下一番苦功，就会有强烈的挫折感，发现编程这么麻烦，没意思。反之，如果突破了这个困难，一切就变得非常美好，编程是多么好玩的事呀。\r\n \r\n　　原因就在于此。希望你能有所感。\r\n','c2','a9'),(10,'JDBC 查询 Map转对象','0','2013-08-13 14:45:00','2013-08-13 14:45:00','看到Hibernate你给一个对象，他就能动态的创建配置文件里面指定的表名，然后把数据录入到数据库，当初感觉是很神奇，不过，好像Hibernate不能动态的分表创建表和录入数据\r\n我这里写了一个公用的类，你给一个对象，告诉我按年还是按月生成表，并告诉我那个字段是不需要在表中创建的，该类就可以动态的分表创建需要的表，并录入数据\r\n注意：\r\n由于业务需要，这里对于字段的支持只有int和Integer，double和Double\r\n还有String，同时对于String统一创建为了Varchar(100)的字段\r\n表会统一创建一个id自增主键\r\n \r\nJava代码  \r\npackage com.xd.nms.util;  \r\nimport java.lang.reflect.Field;  \r\nimport java.text.SimpleDateFormat;  \r\nimport java.util.Date;  \r\nimport java.util.Map;  \r\nimport java.util.Set;  \r\nimport org.apache.commons.logging.Log;  \r\nimport org.apache.commons.logging.LogFactory;  \r\nimport org.springframework.jdbc.core.JdbcTemplate;  \r\n/** \r\n * @说明 动态插入数据和创建表 \r\n * @author 崔素强 \r\n * @version 1.0 \r\n * @since \r\n */  \r\npublic class CommonTableInsert {  \r\n    public static Log logger = LogFactory.getLog(CommonTableInsert.class);  \r\n    /** \r\n     * 入口方法 \r\n     * @param tableName 表前缀 \r\n     * @param dateFormat 格式化方法 \r\n     * @param obj 保存的对象 \r\n     * @return \r\n     */  \r\n    @SuppressWarnings(\"unchecked\")  \r\n    public static int insertObject(String tableName,String dateFormat,Object obj, Map noCol){  \r\n        int re = 0;          \r\n        try {     \r\n            JdbcTemplate jt = (JdbcTemplate) SpringFactory.getObject(\"jdbcTemplate\");  \r\n            SimpleDateFormat format = new SimpleDateFormat(dateFormat);               \r\n            String tname = tableName + \"_\" + format.format(new Date());  \r\n            if(CommonDBUtil.getAllTableName(jt,tname)){ // 如果有某表  \r\n                re = saveObj(jt,tname,obj, noCol); // 保存数据     \r\n            }else{  \r\n                re = createTable(jt,tname,obj, noCol); // 动态创建表  \r\n                if(re == 1){  \r\n                    re = saveObj(jt,tname,obj, noCol); // 保存数据  \r\n                }  \r\n            }                \r\n        } catch (Exception e) {     \r\n            logger.error(\"公用方法插入数据入口方法错误\", e);  \r\n        }            \r\n        return re;     \r\n    }  \r\n    /**   \r\n     * 保存方法，注意这里传递的是实际的表的名称   \r\n     */    \r\n    @SuppressWarnings(\"unchecked\")  \r\n    private static int saveObj(JdbcTemplate jt,String tableName,Object obj, Map noCol){     \r\n        int re = 0;  \r\n        StringBuffer sb = new StringBuffer(\"\");  \r\n        try{                 \r\n            sb.append(\" insert into \" + tableName + \" (\");     \r\n            Map<String,String> map = ObjectUtil.getProAndValMap(obj); // 对象的属性和属性值  \r\n            Map<String,String> mapType = ObjectUtil.getProTypeMap(obj); // 对象的属性类型列表  \r\n            Set<String> set = map.keySet();     \r\n            for(String key : set){  \r\n                // 如果该列不是 非处理列  \r\n                if(noCol.get(key) == null){  \r\n                    sb.append(key + \",\");  \r\n                }  \r\n            }     \r\n            sb.append(\" tableName ) \");                  \r\n            sb.append(\" values ( \");     \r\n            for(String key : set){  \r\n                if(noCol.get(key) == null){  \r\n                    if(mapType.get(key).equals(\"class java.lang.String\")){  \r\n                        sb.append(\"\'\" + (map.get(key) + \"\',\"));  \r\n                    }else{  \r\n                        sb.append(map.get(key) + \",\");  \r\n                    }  \r\n                }  \r\n            }     \r\n            sb.append(\"\'\" + tableName + \"\'); \");   \r\n            re = jt.update(sb.toString());             \r\n        } catch (Exception e) {     \r\n            logger.error(\"公用方法录入数据时错误\", e);  \r\n            logger.error(\"公用方法录入数据语句：\" + sb.toString());  \r\n        }            \r\n        return re;     \r\n    }  \r\n    /**   \r\n     * 根据表名称 和 实体属性 创建一张表 \r\n     * @param tableName   \r\n     * @param obj 具体生成什么样的表看该对象 \r\n     */    \r\n    @SuppressWarnings(\"unchecked\")  \r\n    private static int createTable(JdbcTemplate jt,String tableName,Object obj, Map noCol){     \r\n        StringBuffer sb = new StringBuffer(\"\");     \r\n        sb.append(\"CREATE TABLE `\" + tableName + \"` (\");     \r\n        sb.append(\" `id` int(11) NOT NULL AUTO_INCREMENT,\");  \r\n        Class c = obj.getClass();  \r\n        Field field[] = c.getDeclaredFields();  \r\n        for (Field f : field) {  \r\n            if(noCol.get(f.getName()) == null){  \r\n                String type = f.getType().toString();  \r\n                if(type.equals(\"class java.lang.String\")){// Str  \r\n                     sb.append(\"`\" + f.getName() + \"` varchar(100) DEFAULT NULL,\");     \r\n                }else if(type.equals(\"int\") || type.equals(\"class java.lang.Integer\")){// int  \r\n                    sb.append(\"`\" + f.getName() + \"` int(11) DEFAULT NULL,\");     \r\n                }else if(type.equals(\"double\") || type.equals(\"class java.lang.Double\")){// double  \r\n                    sb.append(\"`\" + f.getName() + \"` double DEFAULT NULL,\");     \r\n                }  \r\n            }  \r\n        }  \r\n        sb.append(\" `tableName` varchar(255) DEFAULT NULL,\");  \r\n        sb.append(\" PRIMARY KEY (`id`)\");     \r\n        sb.append(\") ENGINE=InnoDB DEFAULT CHARSET=utf8;\");     \r\n        try {     \r\n            jt.update(sb.toString());     \r\n            return 1;     \r\n        } catch (Exception e) {  \r\n            logger.error(\"公用方法生成表时错误\", e);  \r\n            logger.error(\"公用方法生成表语句：\" + sb.toString());  \r\n        }     \r\n        return 0;     \r\n    }   \r\n}  \r\n \r\n这个对于之前写的那个动态建表，新增了过滤不需要在表中创建的字段\r\n原理就是读取对象的各个字段属性，如果能加以配置文件或者读取对象属性的标记，那其实能做到基本和Hibernate一致，不但能支持多种类型，还能做字段校验等 ','c4','a10'),(11,'正则JavaScript扫盲篇（高手勿进）','0','2013-08-14 15:42:00','2013-08-14 15:42:00','正则表达式在jquery、linux等随处可见，已经无孔不入。因此有必要对这个工具认真的学习一番。本着认真、严谨的态度，这次总结我花了近一个月的时间。但本文无任何创新之处，属一般性学习总结。\r\n一、思考\r\n1. 案例\r\n       通常系统管理员添加一个普通用户时，都有一些默认密码（如：123456），当新用户登录系统后需要自行修改密码为系统所要求的安全范围内的密码格式。如：密码位数要大于6位，必须是字母、特殊符号（如：下划线）、数字的组合形式。可以这样做：\r\nØ纯JavaScript实现\r\nJs代码  \r\nfunction sumt(){  \r\n        var p_count=0;//是否是则为数字、字母、下划线的组合形式  \r\n        var pwd=document.getElementById(\"txtPWD\").value;  \r\n        //长度验证  \r\n        if(pwd.length<7){  \r\n            alert(\'密码长度必须大于6位！\');  \r\n            return;  \r\n        }  \r\n        //数字验证  \r\n        for(var i=0;i<pwd.length;i++){  \r\n            var p_char=pwd[i];  \r\n            if(p_char>=\'0\'&&p_char<=\'9\'){  \r\n                p_count++;  \r\n                break;  \r\n            }  \r\n        }  \r\n        //字母验证  \r\n        for(var i=0;i<pwd.length;i++){  \r\n            var p_char=pwd[i];  \r\n            if(p_char>=\'a\'&&p_char<=\'z\'){  \r\n                p_count++;  \r\n                break;  \r\n            }  \r\n        }  \r\n        //特殊符号验证  \r\n        if(pwd.indexOf(\'_\')!=-1){  \r\n            p_count++;  \r\n        }  \r\n         \r\n        if(p_count<3){  \r\n            alert(\'密码必须是数字、字母以及下划线组合形式！\');  \r\n        }else{  \r\n            //提交  \r\n        }  \r\n}  \r\n  \r\nØ正则实现\r\nJs代码  \r\n//正则实现  \r\nfunction sumt_reg(){  \r\n      var p_count=0;//是否是则为数字、字母、下划线的组合形式  \r\n      var val=document.getElementById(\"txtPWD\").value;  \r\n      //长度验证  \r\n      if(val.length<7){  \r\n          alert(\'密码长度必须大于6位！\');  \r\n          return;  \r\n      }  \r\n      var regex = /[0-9]/;//数字  \r\n      var regex1 = /[A-Za-z]/;//字母  \r\n      var regex2=/[_]/;//特殊符号  \r\n      if(val.match(regex)){  \r\n          p_count++;  \r\n      }  \r\n      if(val.match(regex1)){  \r\n          p_count++;  \r\n      }  \r\n      if(val.match(regex2)){  \r\n          p_count++;  \r\n      }  \r\n       \r\n      if(p_count<3){  \r\n          alert(\'密码必须是数字、字母以及下划线组合形式！\');  \r\n      }else{  \r\n          //提交  \r\n      }  \r\n}  \r\n  \r\n2.了解正则\r\nØ概念\r\n      正则表达式是对字符串操作的一种逻辑公式，就是用事先定义好的一些特定字符、及这些特定字符的组合，组成一个“规则字符串”，这个“规则字符串”用来表达对字符串的一种过滤逻辑。\r\nØ起源\r\n正则表达式[1]的“鼻祖”或许可一直追溯到科学家对人类神经系统工作原理的早期研究。美国新泽西州的Warren McCulloch和出生在美国底特律的Walter Pitts这两位神经生理方面的科学家，研究出了一种用数学方式来描述神经网络的新方法，他们创新地将神经系统中的神经元描述成了小而简单的自动控制元，从而作出了一项伟大的工作革新。\r\n在1956 年,出生在被马克·吐温（Mark Twain）称为“美国最美丽的城市”之一的哈特福德市的一位名叫Stephen Kleene的数学科学家，他在Warren McCulloch和Walter Pitts早期工作的基础之上，发表了一篇题目是《神经网事件的表示法》的论文，利用称之为正则集合的数学符号来描述此模型，引入了正则表达式的概念。正则表达式被作为用来描述其称之为“正则集的代数”的一种表达式，因而采用了“正则表达式”这个术语。\r\n二、公共方法\r\nJs代码  \r\nfunction execReg(reg,str,msg){  \r\n alert(msg+\":\"+reg.exec(str));  \r\n //alert(msg+\":\"+str.match(reg));  \r\n}  \r\nvar exampl_name;//实例名  \r\nvar reg;//正则表达式  \r\nvar str;//匹配字符  \r\n  \r\n \r\n三、字符集合\r\n字符集合\r\n说明\r\n.\r\n小数点可以匹配除了换行符（\\n）以外的任意一个字符\r\n\\w\r\n可以匹配任何一个字母或者数字或者下划线\r\n\\W\r\nW大写，可以匹配任何一个字母或者数字或者下划线以外的字符\r\n\\s\r\n可以匹配空格、制表符、换页符等空白字符的其中任意一个\r\n\\S\r\nS大写，可以匹配任何一个空白字符以外的字符\r\n\\d\r\n可以匹配任何一个 0~9 数字字符\r\n\\D\r\nD大写，可以匹配任何一个非数字字符\r\n \r\n1. example.1\r\n小数点可以匹配除了换行符（\\n）以外的任意一个字符\r\n返回结果是l\r\nJs代码  \r\nreg=/./;  \r\nstr=\'lixiuli\';  \r\nexampl_name=\"example.1\";  \r\nexecReg(reg,str,exampl_name);  \r\n  \r\n \r\n2. example.2\r\n\\w小写\r\n可以匹配任何一个字母或者数字或者下划线\r\n返回结果是_\r\nJs代码  \r\nreg=/\\w/;  \r\nstr=\'_lixiuli\';  \r\nexampl_name=\"example.2\";  \r\nexecReg(reg,str,exampl_name);  \r\n  \r\n \r\n3. example.3\r\n\\W大写，\r\n可以匹配任何一个字母或者数字或者下划线以外的字符\r\n返回结果是null\r\nJs代码  \r\nreg=/\\W/;  \r\nstr=\'_lixiuli\';  \r\nexampl_name=\"example.3\";  \r\nexecReg(reg,str,exampl_name);  \r\n  \r\n4. example.4\r\n\\s小写\r\n可以匹配空格、制表符、换页符等空白字符的其中任意一个\r\n返回结果是空格\r\nJs代码  \r\nreg=/\\s/;  \r\nstr=\' lixiuli\';  \r\nexampl_name=\"example.4\";  \r\nexecReg(reg,str,exampl_name);  \r\n  \r\n5. example.5\r\n\\S 大写，\r\n可以匹配任何一个空白字符以外的字符\r\n返回结果是l\r\nJs代码  \r\nreg=/\\S/;  \r\nstr=\' lixiuli\';  \r\nexampl_name=\"example.5\";  \r\nexecReg(reg,str,exampl_name);  \r\n  \r\n6. example.6\r\n\\d 小写\r\n可以匹配任何一个 0~9 数字字符\r\n返回结果是5\r\nJs代码  \r\nreg=/\\d/;  \r\nstr=\'lixiuli520\';  \r\nexampl_name=\"example.6\";  \r\nexecReg(reg,str,exampl_name);  \r\n  \r\n7.example.7\r\n\\D大写，\r\n可以匹配任何一个非数字字符\r\n返回结果是l\r\nJs代码  \r\nreg=/\\D/;  \r\nstr=\'lixiuli520\';  \r\nexampl_name=\"example.7\";  \r\nexecReg(reg,str,exampl_name);  \r\n \r\n四、量词，贪婪模式\r\n量词：贪婪模式\r\n说明\r\n{n}\r\n表达式固定重复n次，比如：\"\\w{2}\" 相当于 \"\\w\\w\"\r\n{m, n}\r\n表达式尽可能重复n次，至少重复m次：\"ba{1,3}\"可以匹配 \"ba\"或\"baa\"或\"baaa\"\r\n{m, }\r\n表达式尽可能的多匹配，至少重复m次：\"\\w\\d{2,}\"可以匹配 \"a12\",\"x456\"...\r\n?\r\n表达式尽可能匹配1次，也可以不匹配，相当于 {0, 1}\r\n+\r\n表达式尽可能的多匹配，至少匹配1次，相当于 {1, }\r\n*\r\n表达式尽可能的多匹配，最少可以不匹配，相当于 {0, }\r\n \r\n1.example.8\r\n{n}\r\n表达式固定重复n(此处是2)次\r\n结果是ww\r\nJs代码  \r\nreg=/w{2}/;  \r\nstr=\'wusongti_ww\';  \r\nexampl_name=\"example.8\";  \r\nexecReg(reg,str,exampl_name);  \r\n  \r\n2.example.9\r\n{m,n}\r\n表达式尽可能重复n(此处是3)次，\r\n至少重复m(此处是1)次\r\n结果是iii，而不是iiii\r\nJs代码  \r\nreg=/i{1,3}/;  \r\nstr=\'liiiixiuli\';  \r\nexampl_name=\"example.9\";  \r\nexecReg(reg,str,exampl_name);  \r\n  \r\n3.example.10\r\n{m,}\r\n表达式尽可能的多匹配，\r\n至少重复m(此处是2)次\r\n结果是ii，而不是i\r\nJs代码  \r\nreg=/i{2,}/;  \r\nstr=\'lixiulii\';  \r\nexampl_name=\"example.10\";  \r\nexecReg(reg,str,exampl_name);  \r\n \r\n4.example.11\r\n?\r\n表达式尽可能匹配1次，\r\n也可以不匹配\r\n相当于 {0, 1}\r\n结果是a，而不是null\r\nJs代码  \r\nreg=/a?/;  \r\nstr=\'abbbccc\';  \r\nexampl_name=\"example.11\";  \r\nexecReg(reg,str,exampl_name);  \r\n \r\n  \r\n5. example.12\r\n+\r\n表达式尽可能的多匹配，\r\n至少匹配1次，\r\n相当于 {1, }\r\n结果是ii，而不是i\r\nJs代码  \r\nreg=/i+/;  \r\nstr=\'liixiuli\';  \r\nexampl_name=\"example.12\";  \r\nexecReg(reg,str,exampl_name);  \r\n \r\n \r\n6.example.13\r\n*\r\n表达式尽可能的多匹配，\r\n最少可以不匹配，\r\n相当于 {0, }\r\n结果为iii，而不是null\r\nJs代码  \r\nreg=/i*/;  \r\nstr=\'iiilixiuli\';  \r\nexampl_name=\"example.13\";  \r\nexecReg(reg,str,exampl_name);  \r\n   \r\n \r\n五、量词，非贪婪模式\r\n量词：非贪婪\r\n说明\r\n{m, n}?\r\n表达式尽量只匹配m次，最多重复n次。\r\n{m, }?\r\n表达式尽量只匹配m次，最多可以匹配任意次。\r\n??\r\n表达式尽量不匹配，最多匹配1次，相当于 {0, 1}?\r\n+?\r\n表达式尽量只匹配1次，最多可匹配任意次，相当于 {1, }?\r\n*?\r\n表达式尽量不匹配，最多可匹配任意次，相当于 {0, }?\r\n \r\n1.example.14\r\n{m, n}?\r\n表达式尽量只匹配m次，\r\n最多重复n次。\r\n结果是i，而不是iiii\r\nJs代码  \r\nreg=/i{1,3}?/;  \r\nstr=\'liiiixiuli\';  \r\nexampl_name=\"example.14\";  \r\nexecReg(reg,str,exampl_name);  \r\n  \r\n \r\n2.example.15\r\n{m, }?\r\n表达式尽量只匹配m次，\r\n最多可以匹配任意次。\r\n结果是ii，而不是iii\r\nJs代码  \r\nreg=/i{2,}?/;  \r\nstr=\'lixiuliii\';  \r\nexampl_name=\"example.15\";  \r\nexecReg(reg,str,exampl_name);  \r\n  \r\n \r\n3.example.16\r\n??\r\n表达式尽量不匹配，\r\n最多匹配1次，\r\n相当于 {0, 1}?\r\n结果是null，而不是a\r\n+?\r\nJs代码  \r\nreg=/a??/;  \r\nstr=\'abbbccc\';  \r\nexampl_name=\"example.16\";  \r\nexecReg(reg,str,exampl_name);  \r\n \r\n \r\n4.example.17\r\n表达式尽量只匹配1次，\r\n最多可匹配任意次，\r\n相当于 {1, }?\r\n结果是i，而不是ii\r\nJs代码  \r\nreg=/i+?/;  \r\nstr=\'liixiuli\';  \r\nexampl_name=\"example.17\";  \r\nexecReg(reg,str,exampl_name);  \r\n \r\n\r\n \r\n5.example.18\r\n*?\r\n表达式尽量不匹配，\r\n最多可匹配任意次，\r\n相当于 {0, }?\r\n结果为null，而不是iii\r\nJs代码  \r\nreg=/i*?/;  \r\nstr=\'iiilixiuli\';  \r\nexampl_name=\"example.18\";  \r\nexecReg(reg,str,exampl_name);  \r\n   \r\n \r\n \r\n六、字符边界\r\n字符边界\r\n说明\r\n^\r\n当前位置必须是文本开始位置\r\n$\r\n当前位置必须是文本结束位置\r\n\\b\r\n当前位置的左右两侧，只能有一侧是字母数字或下划线\r\n \r\n1.example.19\r\n^\r\n当前位置必须是文本开始位置\r\n结果是null\r\n \r\nJs代码  \r\nreg=/^i/;  \r\nstr=\'lixiuli\';  \r\nexampl_name=\"example.19\";  \r\nexecReg(reg,str,exampl_name);  \r\n   \r\n \r\n2.example.20\r\n$\r\n当前位置必须是文本结束位置\r\n结果是i\r\nJs代码  \r\nreg=/i$/;  \r\nstr=\'lixiuli\';  \r\nexampl_name=\"example.20\";  \r\nexecReg(reg,str,exampl_name);  \r\n \r\n\r\n\r\n \r\n3.example.21\r\n\\b\r\n当前位置的左右两侧，\r\n只能有一侧是字母数字或下划线\r\n结果是i\r\nJs代码  \r\nreg=/i\\b/;  \r\nstr=\'lixiuli\';  \r\nexampl_name=\"example.21\";  \r\nexecReg(reg,str,exampl_name);  \r\n \r\n  \r\n \r\n七、选择表达式\r\n选择表达式\r\n说明\r\n|\r\n使用竖线 \"|\" 分隔多段表达式，整个表达式可匹配其中任意一段。\r\n1.example.22\r\n|\r\n返回结果为x\r\nJs代码  \r\nreg=/x|u/;  \r\nstr=\'li.xiu.li\';  \r\nexampl_name=\"example.22\";  \r\nexecReg(reg,str,exampl_name);  \r\n \r\n \r\n八、自定义字符集合\r\n自定义字符集合\r\n说明\r\n[ ]\r\n用中括号 [ ] 包含多个字符，可以匹配所包含的字符中的任意一个。同样，每次只能匹配其中一个。\r\n[^]\r\n用中括号 [^ ] 包含多个字符，构成否定格式，可以匹配所包含的字符之外的任意一个字符。\r\n1.example.23\r\n[ ]\r\n用中括号 [ ] 包含多个字符，\r\n可以匹配所包含的字符中的任意一个。\r\n同样，每次只能匹配其中一个。\r\n结果是l\r\nJs代码  \r\nreg=/[\\da-zA-Z]/;  \r\nstr=\'lixiuli123LIXIULI\';  \r\nexampl_name=\"example.23\";  \r\nexecReg(reg,str,exampl_name);  \r\n \r\n \r\n2.example.24\r\n[^ ]\r\n用中括号 [^ ] 包含多个字符，\r\n构成否定格式，\r\n可以匹配所包含的字符之外的任意一个字符。\r\n结果是l\r\nJs代码  \r\nreg=/[^i]/;  \r\nstr=\'lixiuli\';  \r\nexampl_name=\"example.24\";  \r\nexecReg(reg,str,exampl_name);  \r\n   \r\n \r\n九、分组\r\n分组\r\n说明\r\n( )\r\n用括号 ( ) 将其他表达式包含，可以使被包含的表达式组成一个整体，在被修饰匹配次数时，可作为整体被修饰。\r\n另外，用括号包含的表达式，所匹配到的内容将单独作记录，匹配过程中或结束后可以被获取。\r\n \r\n1.example.25\r\n（）\r\n用括号 ( ) 将其他表达式包含，\r\n可以使被包含的表达式组成一个整体，\r\n在被修饰匹配次数时，\r\n可作为整体被修饰。\r\n另外，用括号包含的表达式，\r\n所匹配到的内容将单独作记录，\r\n匹配过程中或结束后可以被获取。\r\n结果是lixiuliwusong,l,g\r\n可以发现后面多出来一个l,g\r\n这是因为括号的作用，原因在倒数第四行。\r\n注：javascript不存在命名分组，我在这浪费了不少时间\r\nJs代码  \r\nreg=/^(i|l).+(g|i)$/;//匹配开头是i或l结尾是g或i的所有字符（除了换行符）  \r\nstr=\'lixiuliwusong\';  \r\nexampl_name=\"example.25\";  \r\nexecReg(reg,str,exampl_name);  \r\n  \r\n \r\n十、反向引用\r\n反向引用\r\n说明\r\n/(子正则表达式)\\编号/\r\n反向引用标识由正则表达式中的匹配组捕获的子字符串。每个反向引用都由一个编号或名称来标识，并通过“\\编号”表示法进行引用。\r\n \r\n1.example.26\r\n由此引出反向引用的使用\r\n此处返回\"l\"\r\nJs代码  \r\nreg=/l/;//匹配l字母  \r\nstr=\'lixiuli\';  \r\nexampl_name=\"example.26\";  \r\nexecReg(reg,str,exampl_name);  \r\n  \r\n \r\n2.example.27\r\n由此引出反向引用的使用\r\n此处返回\"lilu,li,llu\"\r\nlilu是整个正则匹配的结果\r\nli是第一个括号匹配的结果\r\nlu则是第二个括号匹配的结果\r\nJs代码  \r\nreg=/([a-z]{2})([a-z]{2})/;//匹配两个连续字母*2，即匹配四个连续字母  \r\nstr=\'lilucy\';  \r\nexampl_name=\"example.27\";  \r\nexecReg(reg,str,exampl_name);  \r\n   \r\n3.example.28\r\n反向引用\r\n此处返回\"null\"\r\n因为第一个括号li，第二个括号也匹配了li\r\n反向引用\\1则是拿第一个括号的匹配结果去匹配剩余的字符\r\n而剩余的字符没有li，因此返回null\r\nJs代码  \r\nreg=/([a-z]{2})([a-z]{2})\\1/;  \r\nstr=\'lililucy\';  \r\nexampl_name=\"example.28\";  \r\nexecReg(reg,str,exampl_name);  \r\n  \r\n4.example.29\r\n反向引用\r\n此处返回\"lililili,li,li\"\r\nlililili是整个正则匹配的结果\r\n可将lililili分四部分来分析：li li li li\r\n第一个li是第一个括号匹配到的\r\n第二个li是第二个括号匹配到的\r\n第三个li则是反向引用\\1匹配到的\r\n第四个li是反向引用\\2匹配到的\r\n第一个逗号后面的li是第一个括号匹配的结果\r\n第二个逗号后面的li则是第二个括号匹配的结果\r\nJs代码  \r\nreg=/([a-z]{2})([a-z]{2})\\1\\2/;//反向匹配两个括号的内容  \r\nstr=\'lililili\';  \r\nexampl_name=\"example.29\";  \r\nexecReg(reg,str,exampl_name);  \r\n   \r\n \r\n十一、非捕获性分组\r\n非捕获性分组\r\n说明\r\n(?:子表达式)\r\n由于不是所有分组都能创建反向引用，有一种特别的分组称之为非捕获性分组，它是不会创建反向引用。反之，就是捕获性分组。要创建一个非捕获性分组，只要在分组的左括号的后面紧跟一个问号与冒号即可。\r\n1.example.30\r\n题目，移除所有标签，只留下innerText!\r\n结果是：wusongti is a 大神\r\nJs代码  \r\nvar htmlText = \"<p><a href=\'http://9080.iteye.com/\'>wusongti</a> is a <em>大神</em></p>\";  \r\nreg=/<(?:.|\\s)*?>/g;  \r\nvar text = htmlText.replace(reg, \"\");  \r\nalert(text)  \r\n \r\n十二、其他\r\n1.参考文献\r\nØ http://baike.baidu.com/view/94238.htm\r\nØ 《DEELX 正则引擎文档》\r\nØ 其他资料等\r\n2.交流\r\nØ互动联系','c4','a11'),(12,'drools中文乱码解决','0','2013-08-14 18:36:08','2013-08-14 18:36:08','项目中用到了规则引擎，后来选用了drools开源的实现，后来部署的linux环境后乱码，在本地不乱码，所以第一时间就想到了应该是drools内部取了操作系统默认的编码了。\r\n         首先我们知道，凡是乱码基本上是字节和字符之间相互转换的时候出现的，经过仔细排查，发现将规则文件加入到session里面的时候没有给编码，于是加上。\r\n 加载规则文件的时候必须指定编码，比如UTF-8\r\nJava代码  \r\n中文乱码代码：  \r\nReader reader = new FileReader(new File(\"F:/WorkFolder/drools/drl/addpoint.drl\"));  \r\n解决方法：  \r\nReader reader = new InputStreamReader(new FileInputStream(\"F:/WorkFolder/drools/drl/addpoint.drl\"),\"UTF-8\");  \r\n 加上这一处编码还是不行，后来发现我们用的decisiontable的解码是用的jxl，在网上看，jxl的解析也有可能产生乱码，于是加上\r\n给容器启动的时候设置jxl的编码\r\nJava代码  \r\nSystem.setProperty(\"jxl.encoding\", \"UTF-8\");  \r\n 加上这两个系统参数，也是乱码，经过调试发现，org.drools.rule.builder.dialect.java.JavaDialect类里面的addClassCompileTask方法有将字符超字节转换的代码，如下：\r\nJava代码  \r\npublic void addClassCompileTask(final String className,  \r\n                                    final BaseDescr descr,  \r\n                                    final String text,  \r\n                                    final MemoryResourceReader src,  \r\n                                    final ErrorHandler handler) {  \r\n  \r\n       final String fileName = className.replace( \'.\',  \r\n                                                  \'/\' ) + \".java\";  \r\n       try {  \r\n         if (src != null) {  \r\n                src.add( fileName,  \r\n                         text.getBytes() );  \r\n            } else {  \r\n                this.src.add( fileName,  \r\n                              text.getBytes() );  \r\n            }  \r\n       } catch (final UnsupportedEncodingException e ) {  \r\n          throw new RuntimeException(\"unable to encoding the rule!\");  \r\n       }  \r\n        \r\n  \r\n       this.errorHandlers.put( fileName,  \r\n                               handler );  \r\n  \r\n       addClassName( fileName );  \r\n   }  \r\n 我们再来看一下String的getBytes方法的实现，这个方法里面默认取平台的编码的，至此，我们就知道病根了，所以比较简单了，加上-Dfile.encoding=UTF8参数就可以了，注意，这个地方是UTF8，不是UTF-8,具体的解释看官方文档: http://docs.oracle.com/javase/6/docs/technotes/guides/intl/encoding.doc.html，最后这个也是在tomcat的启动参数里面加上-Dfile.encoding=UTF8','c5','a12'),(13,'Ant使用xmltask替换AndroidManifest.xml文件中的配置','0','2013-08-16 06:07:26','2013-08-16 06:07:26','新的游戏项目上线后，接了很过国内的推广渠道的SDK，其中一个很繁琐的问题就是打包，每次升级版本都要打几十个包；如果人肉操作的话非常费劲，而且很容易出错。正好Android的SDK中也提供了ant来脚本化打包操作。所以就针对公司里游戏项目的结构对ant打包脚本，添加了些功能。将游戏中的所有可配置的内容全部整理build.properties文件中，比如说游戏中的日志开关，正式环境和测试环境的测试地址，渠道标记、版本号等等 \r\n\r\n  Ant本身提供了非常便捷灵活的扩展方式，所以有很多第三方的扩展包。xmltask就是一个非常方便的操作xml文件的扩展。http://sourceforge.net/projects/xmltask/ \r\n\r\n1、通过taskdef来引入xmltask \r\nXml代码  \r\n<taskdef name=\"xmltask\" classname=\"com.oopsconsultancy.xmltask.ant.XmlTask\"/>  \r\n\r\n\r\n2、 添加replace-manifest target \r\nXml代码  \r\n<target name=\"-replace-manifest\" >  \r\n    <xmltask source=\"${basedir}/${manifest.file}\" dest=\"${basedir}/${manifest.file}\" encoding=\"utf-8\" >  \r\n        <attr path=\"//manifest\" attr=\"android:versionName\" value=\"${project.versionname}\" />  \r\n        <attr path=\"//manifest\" attr=\"android:versionCode\" value=\"${project.versioncode}\" />  \r\n        <attr path=\"//manifest/application/meta-data[@android:name=\'usedSDK\']\" attr=\"android:value\" value=\"${project.usedSDK}\" />  \r\n        <attr path=\"//manifest/application/meta-data[@android:name=\'debugable\']\" attr=\"android:value\" value=\"${project.debugable}\" />  \r\n        <attr path=\"//manifest/application/meta-data[@android:name=\'usedEntirePack\']\" attr=\"android:value\" value=\"${project.usedEntirePack}\" />  \r\n        <attr path=\"//manifest/application/meta-data[@android:name=\'lazySetGLView\']\" attr=\"android:value\" value=\"${project.lazySetGLView}\" />  \r\n    </xmltask>  \r\n</target>  \r\n\r\nxmltask中的attr 标签中的path是通过xpath方式来定位到xml中节点的，关于xpath 可以查看官方文档[url]http://www.w3.org/TR/xpath/[url] \r\n\r\n3、在java代码中获取AndroidManifest.xml文件中的配置 \r\nJava代码  \r\npublic class AppBase extends Application {  \r\n  \r\n    @Override  \r\n    public void onCreate() {  \r\n        super.onCreate();  \r\n        Platform platform = new AZPlatform();  \r\n        try {  \r\n            ApplicationInfo appInfo = getPackageManager().getApplicationInfo(getPackageName(),  \r\n                    PackageManager.GET_META_DATA);  \r\n  \r\n            Bundle meta = appInfo.metaData;  \r\n            platform.setDebugable(meta.getBoolean(DEBUGABLE_KEY, false));  \r\n            platform.setUsedSDK(meta.getInt(USED_SDK_KEY, 0));  \r\n            platform.setUsedEntirePack(meta.getBoolean(USED_ENTIRE_PACK_KEY, true));  \r\n            platform.setLazySetGLView(meta.getBoolean(LAZY_SET_GLVIEW_KEY, false));  \r\n  \r\n            Cocos2dxHelper.PLATFORM_INST = platform;  \r\n        } catch (NameNotFoundException e) {  \r\n            e.printStackTrace();  \r\n        }  \r\n    }  \r\n}  \r\n\r\nPlatform 是针对不同渠道做的一个单例模板类，设置完一些平台相关的配置后，注入到Cocos2dxHelper中，便于Cocos2dx的lib包中使用 ','c5','a13'),(14,'js的作用域链','0','2013-08-17 09:12:13','2013-08-17 09:12:13','这几天学习了一下javascript作用域链，感到这个挺重要的，所以写一篇文章分享一下：\r\n1. 作用域链：\r\n           当代码在一个环境中执行时，会创建由变量对象构成的一个作用域链。作用域链的用途是：保证对执行环境有权访问的所有变量和函数的有序访问。\r\n \r\n2. 在作用域链中查找标识符：\r\n           当在某环境中为了读取或写入而引用一个标识符时，必须通过搜索来确定该标识符实际代表什么。搜索过程从作用域链的前端开始，向上逐级查询与给定名字匹配的 标识符。如果在局部环境中找到该标识符，搜索过程停止，变量就绪。如果在局部环境中没有找到该变量名，则继续沿作用域链向上搜索。搜索过程将一直追溯到全 局环境的变量对象。如果在全局环境中也没有找到这个标识符，则意味着这个标识符为声明。\r\n           当执行流进入一个函数中，函数的环境就会被推入一个环境栈中，而在函数执行后，栈将其环境弹出，把控制权返回给之前的执行环境。\r\n \r\n3.  现在就来看看例子吧。。。\r\n \r\nJs代码  \r\n3.1    var name = \"hello\";  \r\n         function test(){  \r\n               alert(name); //undefined  \r\n               var name = \"world\";  \r\n               alert(name);  //world  \r\n         }  \r\n         test();  \r\n \r\n分析：  首先函数test（）的作用域链包含两个对象：他自己的变量对象和全局的变量对象。在全局变量对象（即就是Window对象）中存在 name=“hello”和Window对象自身所持有的一些属性，全局作用域被放在作用域链的最末端。现在来说说test自身的变量对象，有 alert,name,alert这三个变量，因为test函数还没有执行所以此时的name属性的值就是undefined，因此当解析到alert(name); //undefined这一句话的时候，js引擎会在自身的对象作用域中找到name属性，并且输出他的值（undefined），当执行到var name = \"world\";时name属性的值已经被赋值为world了因此下一条alert就打印出world了！\r\n \r\nJs代码  \r\n3.2    var name = \"hello\";  \r\n         function test(){  \r\n            alert(name);   //hello  \r\n            name = \"world\";  \r\n            alert(name);   //world  \r\n          }  \r\n          test();  \r\n \r\n分析： 此时也和上面的一样，都有两个作用域对象，Window作用域对象和上面分析的一样（name=hello），现在来分析分析test的作用域：因为在 js中存在预编译的过程，即就是：js在执行每一段js代码之前，都会首先处理var关键字和function定义式。但因为此时的test内部没有 var声明的变量，所以此时name属性没有在test这个作用域里面，这里要说一句：在使用var关键字声明的变量时，这个变量将被自动添加到距离最近 的可用环境中，对于函数而言，这个最近的环境就是函数的局部环境。如果变量在未经声明的时候被初始化，那么该变量会自动被添加到全局环境。因此name现 在已经被为全局作用域对象中的属性了。但是其值依旧还是hello，因为还没有执行到name = \"world\";因此当第一条alert(name);   //hello时候会在全局环境变量中查找到hello的值，当执行了 name = \"world\";全局变量中的name就被赋值为world了，因此在进行alert(name);   //world的时候就是world了。\r\n \r\nJs代码  \r\n3.3   name = \"hello\";  \r\n        function test(){  \r\n            alert(name);  //undefined    ---》》》在自己的作用域中查找到的  \r\n            var name = \"world\";          \r\n            alert(name);  //world  \r\n        }  \r\n   \r\n        test();  \r\n   \r\n        name = \"hello\";  \r\n        function test(){  \r\n            alert(name);    //hello  \r\n            name = \"world\";  \r\n            alert(name);    //world  \r\n        }  \r\n        test();  \r\n接下来这两种情况出现的值就很好分析了。。。\r\n \r\n \r\n补充：\r\n        在web浏览器中，全局执行环境被认为是Window对象，因此所有的全局变量和函数都是作为Window对象的属性和方法创建的，某个执行环境中的所有 代码执行完毕后该环境被销毁，保存在其中的所有变量和函数定义也随之销毁。全局执行环境知道应用程序退出-----例如关闭浏览器或者网页时才会销 毁！！！','c6','a14'),(15,'哈弗曼树及哈弗曼编码简述','0','2013-08-17 10:45:00','2013-08-17 10:45:00','哈弗曼树是一种特殊的二叉树。 \r\n　　定义：　　构造一棵二叉树，若该二叉树的带权路径长度为最小值，则此二叉树可称为哈弗曼树。 \r\n　　解释：　　带权路径长度：树中各叶结点到根结点需要经过的最短层数与该结点上权值的乘积之和。 \r\n　　构造方法：　　若有n个权值，则构建成功的哈弗曼树有n个叶结点。取n个结点中权值最小的两个合并，作为一棵新树的左右子树，新树根结点的权数为两子结点的权数之和。将新根结点权值与余下n-2个结点比较，得出权值最小的两个结点，再重复上述操作。 \r\n　　下面以权值分别为1、2、3、4、5的5个结点为例，来说明哈弗曼树的构造过程。 \r\n　　初始状态为五棵只有根结点的树组成的森林：　 \r\n     \r\n　　在五个结点中，1、2的权值最小，将1、2合并，作为新树的左右结点，新树根结点的权值为1、2之和：　　 \r\n     \r\n　　将新树的根结点与余下3个根结点比较，3、3的权值最小，合并得新根结点：　 \r\n     \r\n　　在三个根结点中，4、5最小，合并成新树：　　 \r\n     \r\n　　最后，在将6、9合并，得到一棵有5个叶结点的树：　　 \r\n     \r\n\r\n　　用途：　　在计算机中，假设我们需要存储一段英文信息，那么出于节省存储空间、减少传输流量的考虑，我们一定是希望这段信息占用的空间越小越好。 \r\n　　如何达到这个目的呢？我们知道，一个英文字符占据一个字节大小，这是由计算机内部的编码解码规则决定的。在这种情况下，这段信息占据的大小就是固定的，不存在减少的可能。既然如此，为什么不自己定义一套编码解码的规则呢？根据一般规律，一段英文信息中一定有某些字母的使用频率较高，那么用最短的01串代表最常用的字母，字母使用频率越高代表它的01串就越短，这样就可以达到减少所需存储空间的目的。 \r\n　　至于如何获得代表各字母的01串，那就要靠哈弗曼编码了。上文中提到的方法，实际就是哈弗曼树中最短带权路径长度的概念。以每个字母的出现次数或频率作为权值，构造哈弗曼树，然后从根结点开始，左子树代表0，右子树代表1，依次往下推导，就可得出个字母的01串了。 \r\n　　以上图为例，代表5个权值的01串分别为： \r\n　　1：000 \r\n　　2：001 \r\n　　3：01 \r\n　　4：10 \r\n　　5：11 \r\n　　 \r\n　　在掌握了基本的规则之后，我们也可以通过程序来实现哈弗曼编码的获得。 \r\n　　程序一共需要4个类： \r\n　　 \r\n　　数据类：定义数据的属性及属性的setter、getter方法。属性应有：数据内容（如字母a或其他）、数据出现次数、数据的哈弗曼编码。 \r\nJava代码  \r\n/** \r\n * 数据类，每个数据都应有数据内容，出现次数，和它的哈弗曼编码 \r\n */  \r\npublic class Data {  \r\n    private int number;  \r\n    private int time;  \r\n    private String code;  \r\n      \r\n    public int getNumber() {  \r\n        return number;  \r\n    }  \r\n    public void setNumber(int number) {  \r\n        this.number = number;  \r\n    }  \r\n    public int getTime() {  \r\n        return time;  \r\n    }  \r\n    public void setTime(int time) {  \r\n        this.time = time;  \r\n    }  \r\n    public String getCode() {  \r\n        return code;  \r\n    }  \r\n    public void setCode(String code) {  \r\n        this.code = code;  \r\n    }  \r\n      \r\n      \r\n}  \r\n\r\n　　结点类：定义结点的属性及属性的setter、getter方法。属性应有：结点代表的数据，该结点的左右子结点。 \r\nJava代码  \r\n/** \r\n * 结点类，每个结点都应有左右子树、结点代表的数据 \r\n */  \r\npublic class Node {  \r\n    private Data data;  \r\n    private Node leftChild;  \r\n    private Node rightChild;  \r\n      \r\n    public Data getData() {  \r\n        return data;  \r\n    }  \r\n    public void setData(Data data) {  \r\n        this.data = data;  \r\n    }  \r\n    public Node getLeftChild() {  \r\n        return leftChild;  \r\n    }  \r\n    public void setLeftChild(Node leftChild) {  \r\n        this.leftChild = leftChild;  \r\n    }  \r\n    public Node getRightChild() {  \r\n        return rightChild;  \r\n    }  \r\n    public void setRightChild(Node rightChild) {  \r\n        this.rightChild = rightChild;  \r\n    }  \r\n      \r\n}  \r\n\r\n哈弗曼树类：定义创建哈弗曼树的方法和将哈弗曼编码显示出来的方法。 \r\nJava代码  \r\n/** \r\n * 传入数据数组，获取各数据的哈弗曼编码 */  \r\npublic class HfmTree {  \r\n    public Data[] data;  \r\n  \r\n    public HfmTree(Data[] data) {  \r\n        this.data = data;  \r\n    }  \r\n  \r\n    /** \r\n     * 将数据数组转换为结点数组 \r\n     * @param 要转换的数据数组 \r\n     * @return 转换得到的结点数组 \r\n     */  \r\n    public Node[] arrToNode(Data[] data) {  \r\n        Node[] nodes = new Node[data.length];  \r\n        for (int i = 0; i < data.length; i++) {  \r\n            Node node = new Node();  \r\n            nodes[i] = node;  \r\n            nodes[i].setData(data[i]);  \r\n        }  \r\n        return nodes;  \r\n    }  \r\n  \r\n    /** \r\n     * 将结点数组按数据出现的次数进行从小到大的排列（冒泡排序） \r\n     * @param 要进行排列的结点数组 \r\n     */  \r\n    public void sortNode(Node[] nodes) {  \r\n        for (int i = 0; i < nodes.length; i++) {  \r\n            for (int j = i + 1; j < nodes.length; j++) {  \r\n                if (nodes[i].getData().getTime() > nodes[j].getData().getTime()) {  \r\n                    Node temp = nodes[i];  \r\n                    nodes[i] = nodes[j];  \r\n                    nodes[j] = temp;  \r\n                }  \r\n            }  \r\n        }  \r\n    }  \r\n  \r\n    /** \r\n     * 建立哈弗曼树方法 \r\n     * @return  只有一个最终根结点的数组 \r\n     */  \r\n    public Node[] creatHfmTree() {  \r\n        //定义存储根结点的数组，并用由数据数组转换而来的结点数组初始化  \r\n　　Node[] nodes = this.arrToNode(data);  \r\n　　//循环进行排序，合并结点，获得新根结点，获得新根结点数组操作  \r\n        while (nodes.length > 1) {  \r\n            this.sortNode(nodes);  \r\n            Node n1 = nodes[0];  \r\n            Node n2 = nodes[1];  \r\n            Node n3 = new Node();  \r\n            Data data = new Data();  \r\n            data.setTime(n1.getData().getTime() + n2.getData().getTime());  \r\n            n3.setData(data);  \r\n            n3.setLeftChild(n1);  \r\n            n3.setRightChild(n2);  \r\n  \r\n            Node[] nodes2 = new Node[nodes.length - 1];  \r\n            nodes2[0] = n3;  \r\n            for (int i = 2; i < nodes.length; i++) {  \r\n                nodes2[i - 1] = nodes[i];  \r\n            }  \r\n            nodes = nodes2;  \r\n        }  \r\n        return nodes;  \r\n    }  \r\n      \r\n    /** \r\n     * 应用递归打印各数据的哈弗曼编码 \r\n     * @param node  第一次传入根结点 \r\n     * @param code  第一次传入\"\" \r\n     */  \r\n    public void printCode(Node node,String code){  \r\n        if(node.getLeftChild()!=null){  \r\n            this.printCode(node.getLeftChild(), code+\"0\");  \r\n        }  \r\n        if(node.getRightChild()!=null){  \r\n            this.printCode(node.getRightChild(),code+\"1\");  \r\n        }  \r\n        if(node.getLeftChild()==null&&node.getRightChild()==null){  \r\n            System.out.println(\"数\"+node.getData().getNumber()+\"次数为\" +  \r\n                    node.getData().getTime()+\"编号为\"+code);  \r\n        }  \r\n    }  \r\n}  \r\n\r\n测试类：测试程序的正确性。随机建立一个数据数组并获得各数据的哈弗曼编码。 \r\nJava代码  \r\nimport java.util.Random;  \r\n  \r\npublic class Test {  \r\n      \r\n    public static void main(String args[]){  \r\n        Data[] datas = new Data[10];  \r\n        Random r = new Random();  \r\n        int ran;  \r\n        for(int i =0;i<10;i++){  \r\n            Data data = new Data();  \r\n            ran = r.nextInt(50);  \r\n            data.setNumber(ran);  \r\n            ran = r.nextInt(20);  \r\n            data.setTime(ran);  \r\n            datas[i] = data;  \r\n        }  \r\n        HfmTree ht = new HfmTree(datas);  \r\n        Node[] nodes =ht.creatHfmTree();  \r\n        String code = \"\";  \r\n        ht.printCode(nodes[0], code);  \r\n    }  \r\n}  \r\n　　程序运行结果如下： \r\n\r\n     \r\n\r\n　　可以自行验证程序结果的正确性。 \r\n　　使用随机数的问题：有可能得到相同的数据内容。对此，多运行几次即可得到满意的实验数据。','c6','a15'),(16,'Hbase MTTR介绍','0','2013-08-18 14:25:00','2013-08-18 14:25:00','Hbase 是一个always-available的服务，在机器故障的时候保持可用性，集群中的机器都运行regionserver daemons。但一个regionserver出现故障，或者机器掉线，那么保存在上面的regions也同样掉线。Hbase中MTTR的能够检测异常，尽可能早的恢复对掉线region的访问。 \r\n文章解释了hbase如何管理MTTR，并且介绍了一些hbase和hdfs的设置。 \r\n\r\nHbase是一致性时对故障的如何保持弹性 \r\n\r\nHbase通过让一个单独的server负责数据的子集，也就是说，一个region在同一时刻只能被一个region server进行管理。 \r\n\r\nHbase对失败的弹性，归功于hdfs，因为在写数据的时候，数据会被复制到到不通的节点。 \r\nHbase将数据写入到hfiles中，hfile保存在hdfs上面，hdfs完成对hfiles的block的副本（replica）。默认情况下是副本数是3. \r\nHbase使用commit log（或者称之为Write-Ahead-log，WAL），提交日志也同样写在HDFS上面，默认副本数为3. \r\n\r\nHbase在故障检测以及访问恢复的步骤： \r\n识别宕机的节点（Identifying that a node is down）：由于过载或者直接死掉，节点会不再响应。 \r\n在write操作进行中的时候进行恢复（Recovering the writes in progress):通过读取commit log，恢复还没有被flush的edit。 \r\n重新分配region：失败的regionserver之前在正在处理一些region，这些region需要被重新分配给其他的RS（regionSever），这个分配过程要根据每台RS不通的workload的情况 \r\n那上面三个过程中哪一个步骤最痛苦？在检测以及恢复步骤发生的时候，客户端会被阻塞。MTTR的作用就是加速这个处理过程，让客户端对数据downtime的感知时间尽可能的短。 \r\n\r\n检测失败节点： \r\n一个RS的失败原因很多：正常的情况下，可能是由于clean stop，比如管理员关闭了某个节点，这就允许RS能安全适当的关闭region，然后告诉HMaster，正在关闭。这种情况下，commit log会被清除，然后HMaster会立刻安排region的重新分配。 \r\n另外的regionserver关闭的的情况：比如运行RS的计算机静默死亡（silent death），比如网络原因。导致region server不能够发出告警，这种情况有Zookeeper进行处理。 每一个RS都会连接到Zookeeper上面，而Master监测这些连接，Zookeeper自己管理heartbeat。所以timeout出现的时候，Hmaster会申明region server 已经死亡，启动一个恢复处理过程 \r\n\r\n\r\n恢复正在进行中的写操作。 \r\n当一个RS 出现了宕机，那么commit logs的恢复工作就发生了。这个恢复工作是并行开始的。 \r\n第一步：随机的RS会提取commit logs（从设置好的commit log 目录中），并且按照region来分割日志成多个文件，保存在HDFS上面，然后region会被重新分配给其他任意的RS， \r\n然后每一个被分配的RS的都会去读取已经前面分割好的对应的region 日志文件，并且进行将该region恢复到正确状态。 \r\n\r\n当出问题的是一个node 失败了，而不是一个进程崩溃了，那么问题就会出现了。 \r\n出现进程崩溃的的regionserver，会将数据写入到处于同一台机上面的datanode上面。假设副本因素为3，那么当一个node丢失的时候，你丢失的不仅仅是一个region server，并且还有这个数据的一个副本。 进行split，就意味着要读取block，而1/3的副本已经死了，那么对于每一个block，你会有三分之一的几率被引导到错误的副本上面。还有，split操作需要创建新的文件。每一个文件都会有3个副本，这些副本可能会被指派给已经丢失的datanode，而这个write数据的过程由于datanode已经死亡，会在经过一个timeout之后失败，而重新回转到另外一个datanode上面，这就延缓了数据的恢复的过程。 \r\n\r\n重新分配region \r\n分配region的工作会进行的很快，这依赖于Zookeeper，需要通过Zookeeper完成master和region server的异步工作。 \r\n\r\n\r\nMTTR带来的提升（The MTTR improvements） \r\n检测失败节点： \r\n首先，可以减小默认的timeout时间。Hbase 被配置成3分钟的Zookeepertimeout时间，这就保证了GC不会介入进来（GC parse会导致ZK的timeout，会导致错误的failure检测。） \r\n对于生产系统，关注MTTR的话，设置timeout时间为1分钟，或者30秒，是很有必要的。 \r\n一个合理的最小设置时20秒。所以你可以设置hbase.zookeeper.timeout=60000 \r\n你同样设置你GC(incremental, generational GC with good figures for the young and old generations, etc., this is a topic by itself) ，这样使GC的暂停时间不要超过ZK timeout。 \r\n\r\n\r\n\r\n恢复正在进行中的写操作。 \r\n在正常情况下，会有足够的活跃的RS来并行的完成commit log files的split工作，所以问题的就转到能否直接找到HDFS上面仅存的副本。该问题的解决方案是，配置HDFS，是hdfs对于故障的检测快于hbase的检测。那就是说，如果hbase的timeout为60s，HDFS应该设置成20s（就是设置成20s之后就认为node已经死亡）。在这里我们要描述一下HDFS是如何处理dead node。HDFS的故障检测也同样是依赖于heartbeat和timeout，在HDFS中，如果一个node被申明为dead，那么保存在该datanode上面的replicas将会被复制到其他活跃的datanode上面去，而这个是一个消耗很大的过程，并且，如果多个datanode同事死亡，那么这就会引发“replication storms”，replication storms指所有的副本被重新拷贝，这会加剧系统负载，从而导致某些节点不响应，进而导致这些节点被NN视为已经死亡，而这些节点上面block又要重新被复制，周而复始，这样的replication storms实在是可怕了。 \r\n因此，HDFS在开始恢复过程之前会等待一段时间，会比10分钟长一点。而这一点，对于低延时系统来说就是一个问题:访问dead datanode就会促发timeout。在HDFS versions 1.0.4 or 1.2, and branches 2 and 3中，引入一个新的状态：stale。当一个datanode不再发送hearbeat，并且这个时间持续到一个指定的时间，那么datanode处于stale状态。 处于stale状态的节点就是在读写过程中最后一个选择（a last resort for reads），所以启用这种性质，会是恢复更加快。 \r\n设置启用stale的方法：修改hdfs-site.xml \r\n<!-- stale mode - 1.2+ --> \r\n<property> \r\n   <name>dfs.namenode.avoid.read.stale.datanode</name> \r\n   <value>true</value> \r\n</property> \r\n<property> \r\n   <name>dfs.namenode.avoid.write.stale.datanode</name> \r\n   <value>true</value> \r\n</property> \r\n\r\n<property> \r\n   <name>dfs.namenode.write.stale.datanode.ratio</name> \r\n   <value>1.0f</value> \r\n</property> \r\n<!-- stale mode - branch 1.1.1+ --> \r\n<property> \r\n   <name>dfs.namenode.check.stale.datanode</name> \r\n   <value>true</value> \r\n</property> \r\n注：我在cloudera cdh-4.1.2 提供的doc的配置项目文档中没有找到该参数，看了源码才找到这些参数。 \r\n具体参考HDFS-3912, HDFS-4350: \r\n\r\n重新分配region \r\nRegion分配的是纯粹hbase的内部实现，在Hbase 0.94+的版本中，region 分配过程的处理被优化了，允许在很短的时间异步分贝更多的region。 \r\n具体可以参考[example - Apache jira HBASE-7247]. \r\n\r\n结论。 \r\n在Hbase中没有global failure，如果一个region server 失败了，其他的region server 仍然可用，对于给定的一个数据集，MTTR 通常是 10分钟左右。 \r\n该经验数值是从是从比较普遍的情况是中得到的，因为需要使用dead datanode的节点上面副本数，恢复就需要时间。HDFS需要花费10分钟的时间来申明datanode死亡了。 当引入了stale状态的时候，这就不再是一个问题了。这个时候恢复时间就变成Hbase本身的问题，如果你需要考虑MTTR，那么你采用这里的设置，从节点真的出现失败，到数据在其他RS上面又重新变得可用，这个过程只需要2分钟，或者更少。','c7','a16'),(17,'spring mvc hello World 非annotation','0','2013-08-18 08:06:23','2013-08-18 08:06:23',' 导入相应的jar包：\r\n\r\n \r\n web.xml文件的配置：\r\nXml代码  \r\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>  \r\n<web-app version=\"2.5\"   \r\n    xmlns=\"http://java.sun.com/xml/ns/javaee\"   \r\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"   \r\n    xsi:schemaLocation=\"http://java.sun.com/xml/ns/j2ee  \r\n    http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd\">  \r\n      \r\n    <!-- springMVC配置 -->  \r\n    <servlet>  \r\n        <description>springMVC配置</description>  \r\n        <servlet-name>Dispatcher</servlet-name>  \r\n        <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>  \r\n        <load-on-startup>1</load-on-startup>  \r\n        <init-param>  \r\n            <param-name>contextConfigLocation</param-name>  \r\n            <param-value>/WEB-INF/Dispatcher-servlet.xml</param-value>  \r\n        </init-param>  \r\n    </servlet>  \r\n    <servlet-mapping>  \r\n        <servlet-name>Dispatcher</servlet-name>  \r\n        <url-pattern>/</url-pattern>  \r\n    </servlet-mapping>  \r\n  \r\n    <!-- spring编码配置 -->  \r\n    <filter>  \r\n        <filter-name>CharacterEncodingFilter</filter-name>  \r\n        <filter-class>org.springframework.web.filter.CharacterEncodingFilter</filter-class>  \r\n        <init-param>  \r\n            <param-name>encoding</param-name>  \r\n            <param-value>utf-8</param-value>  \r\n        </init-param>  \r\n    </filter>  \r\n    <filter-mapping>  \r\n        <filter-name>CharacterEncodingFilter</filter-name>  \r\n        <url-pattern>/*</url-pattern>  \r\n    </filter-mapping>  \r\n      \r\n    <welcome-file-list>  \r\n        <welcome-file>hello</welcome-file>  \r\n    </welcome-file-list>  \r\n</web-app>  \r\n \r\n \r\nSpring mvc配置文件的配置：\r\nXml代码  \r\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>  \r\n<beans xmlns=\"http://www.springframework.org/schema/beans\"  \r\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"  \r\n    xmlns:p=\"http://www.springframework.org/schema/p\"  \r\n    xmlns:context=\"http://www.springframework.org/schema/context\"  \r\n    xsi:schemaLocation=\"  \r\n        http://www.springframework.org/schema/beans  \r\n        http://www.springframework.org/schema/beans/spring-beans.xsd  \r\n        http://www.springframework.org/schema/context  \r\n        http://www.springframework.org/schema/context/spring-context.xsd\">  \r\n    <!--  \r\n  \r\n        BeanNameUrlHandlerMapping：表示将请求的URL和Bean名字映射，如URL为“上下文/hello”，则Spring配置文件  \r\n        必须有一个名字为“/hello”的Bean，上下文默认忽略。  \r\n        SimpleControllerHandlerAdapter：表示所有实现了org.springframework.web.servlet.mvc.Controller 接口的Bean 可以作为  \r\n        Spring Web MVC中的处理器。如果需要其他类型的处理器可以通过实现HadlerAdapter 来解决。  \r\n    -->  \r\n      \r\n    <!-- HandlerMapping -->  \r\n    <bean class=\"org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping\" />  \r\n    <!-- HandlerAdapter -->  \r\n    <bean class=\"org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter\" />  \r\n      \r\n    <!--  \r\n        InternalResourceViewResolver：用于支持Servlet、JSP视图解析；  \r\n        viewClass：JstlView表示JSP模板页面需要使用JSTL标签库，classpath中必须包含jstl的相关jar 包；  \r\n        prefix 和suffix：查找视图页面的前缀和后缀（前缀[逻辑视图名]后缀），比如传进来的逻辑视图名为hello，则该该  \r\n        jsp视图页面应该存放在“WEB-INF/jsp/hello.jsp”；  \r\n    -->  \r\n      \r\n    <!-- ViewResolver -->  \r\n    <bean class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\">  \r\n        <property name=\"viewClass\" value=\"org.springframework.web.servlet.view.JstlView\"/>  \r\n        <property name=\"prefix\" value=\"/WEB-INF/pages/\"/>  \r\n        <property name=\"suffix\" value=\".jsp\"/>  \r\n    </bean>  \r\n      \r\n    <!-- 处理器-->  \r\n    <bean name=\"/hello\" class=\"com.lushuifa.web.HelloWorldController\" />  \r\n  \r\n</beans>  \r\n 控制器编写：\r\nJava代码  \r\npackage com.lushuifa.web;  \r\n  \r\nimport javax.servlet.http.HttpServletRequest;  \r\nimport javax.servlet.http.HttpServletResponse;  \r\n  \r\nimport org.springframework.web.servlet.ModelAndView;  \r\nimport org.springframework.web.servlet.mvc.Controller;  \r\n  \r\npublic class HelloWorldController implements Controller{  \r\n  \r\n    /** \r\n     * ModelAndView：包含了视图要实现的模型数据和逻辑视图名；“mv.addObject(\"message\", \"Hello World!\"); \r\n        ”表示添加模型数据，此处可以是任意POJO对象；“mv.setViewName(\"hello\");”表示设置逻辑视图名为“hello”， \r\n        视图解析器会将其解析为具体的视图，如前边的视图解析器InternalResourceVi。wResolver 会将其解析为 \r\n        “WEB-INF/jsp/hello.jsp”。 \r\n     */  \r\n    public ModelAndView handleRequest(HttpServletRequest arg0,  \r\n            HttpServletResponse arg1) throws Exception {  \r\n        //1、收集参数、验证参数  \r\n        //2、绑定参数到命令对象  \r\n        //3、将命令对象传入业务对象进行业务处理  \r\n        //4、选择下一个页面  \r\n        ModelAndView mv = new ModelAndView();  \r\n        //添加模型数据可以是任意的POJO对象  \r\n        mv.addObject(\"message\", \"第一次Spring mvc 已运行成功！\");  \r\n        //设置逻辑视图名，视图解析器会根据该名字解析到具体的视图页面  \r\n        mv.setViewName(\"hello\");  \r\n        return mv;  \r\n    }  \r\n  \r\n}  \r\n hello world页面：\r\nHtml代码  \r\n<%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%>  \r\n<!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\"  \r\n\"http://www.w3.org/TR/html4/loose.dtd\">  \r\n<html>  \r\n<head>  \r\n<meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\">  \r\n<title>Hello World</title>  \r\n</head>  \r\n<body>  \r\n   ${message}  \r\n</body>  \r\n</html>  \r\n 最后输出结果：\r\n','c7','a17'),(18,'Linux 使用 vsftpd 限制登陆用户访问和修改某个文件夹 （FTP）','0','2013-07-15 14:25:00','2013-07-15 14:25:00','开发中有个需求，需要在服务器开通一个FTP账号给其他人用，让他们上传东西到我们的服务器。但是又不能让他们访问主机的其他目录，所以用到vsftpd这个东西。\r\n我们的主机系统是RHEL 9 ，自带了 vsftpd，如果你的系统没有vsftpd，先自行安装一个，可以上网搜索如何安装。\r\n设置步骤：\r\n1.假设需要建立FTP登陆用户名为test。被限制路径为/home/test\r\n2.linux建立用户 ：\r\nuseradd -d /home/test test //增加用户test，并制定test用户的主目录为/home/test\r\npasswd test //为test设置密码\r\n3.权限设置\r\n   a.关闭用户test telnet权限，使其不能通过ssh登陆，只能通过vsftpd的调用登陆\r\n      usermod -s /sbin/nologin test\r\n   b.vsftpd调用系统验证用户登录时的bin目录\r\n      usermod -s /bin/bash test\r\n   c.usermod -d /home/test test 更改用户test的主目录为/home/test\r\n4.限制用户只能访问/home/test，不能访问其他路径\r\n修改/etc/vsftpd/vsftpd.conf如下：\r\n \r\nchroot_list_enable=YES //限制访问自身目录\r\n# (default follows)\r\nchroot_list_file=/etc/vsftpd/vsftpd.chroot_list\r\n保存退出\r\n5.修改 /etc/vsftpd/vsftpd.chroot_list  （将受限制的用户添加进去，每个用户名一行）\r\n在第一行加上 test\r\n6 重启vsFTPd服务器\r\n/etc/init.d/vsftpd restart 或者 service vsftpd restart\r\n \r\n7.如果需要允许用户修改密码，但是又没有telnet登录系统的权限：\r\n \r\nusermod -s /usr/bin/passwd test //用户telnet（SSH）后将直接进入改密界面\r\n \r\n可能出现问题\r\n1.vsftp 500 OOPS: cannot change directory\r\n在终端输入命令：\r\nsetsebool -P ftpd_disable_trans 1\r\n \r\nservice vsftpd restart\r\n \r\n这样每次重启机器都可以了·\r\n原因就在SELinux。\r\n2.连接时出现\r\n530 Login incorrect\r\n这种情况多数是配置用户的问题，网上的解决方法不一\r\n如果出现这种情况，再执行一次\r\nusermod -s /bin/bash test 试试\r\n目录 /bin/bash 一定要存在','c6','a18'),(19,'工程师的生活','0','2013-05-15 18:25:36','2013-05-15 18:25:36','我忽然很好奇，想知道其他软件工程师的生活是什么样的？人永远都没有活在别人心中的形象那么绚烂，生活中总有无数烂事烦事需要处理，但是每个人都有自己享受生活的方式。逛了逛了各式技术博客和论坛，我发现大家似乎都太严肃了，太谦逊了，太学术了。做软件本来是一件很有意思的事情，但是这些帖子和文章无非就包括这么几种：\r\n\r\n技术文章，不解释，这部分当然是大头，虽然技术文章普遍不受欢迎；\r\n牢骚，喵了个咪的薪水低啊，呜了个汪的加班苦啊；\r\n心灵鸡汤，要励志、要发奋、要改变世界；\r\n长者语气教育后辈，“给刚入职的程序员们的警示”；\r\n无聊的纷争，Linux就是比Windows牛逼，Java就是一门屎尿屁的语言……\r\n做软件的人只是如此吗？就只有上面这几条单调的事情可以聊？工程师就不能记录更丰富的生活吗？在大多数人都在谈论生活品质的时候，工程师也应该跟上脚步。我相信Geek的生活有人羡慕也只能算少数，码农的生活虽司空见惯但他们才是最大的群体，才是软件行业未来的希望。既然没有任何人提及软件工程师的生活品质，那我愿意做第一个吃螃蟹的人：\r\n\r\n成为工程师，而不是码农。如果你连这样的愿望都没有，我们的不同点太多，就算我白啰嗦了。\r\n\r\n寻找不同的享乐方式。为什么把享受放在那么靠前的位置？不是说要先奋斗后享乐吗？这样想的话，说不定你已经被洗过脑了。你的成功不会和享乐冲突的，每个人都可以选择自己的生活方式，谁都有自己的衡量标准，但是在我看来，只有在苦中坚持而不会作乐的生活才是百分百失败的。\r\n\r\n为你和你自己的梦想而工作。不要单纯为公司而工作，也不要只是为父母而工作。知道得少不可怕，可怕的是知道的都是被洗脑了的。容许其他人说那些大道理，容许那些心灵鸡汤天天试图灌你喝，自己千万要清醒，要对自己负责。那些为了公司而拼了命的人，并不是你的榜样。前两天看到一条评论根深蒂固加班文化的奴才机制，过度工作导致又有某某人猝死，却有大部分回复是在说“请注意锻炼一下”，这让我感到无比悲哀和寒心，这里的问题是“锻炼”不够的问题么？\r\n\r\n尊重、容忍和改变。我在《致那些自嘲码农的苦逼程序员》里面已经说过了，我们都理解那些迫不得已的事情，隐忍是在等待时机，蛰伏是有明确目的的，是为了冲破现状，追寻更接近理想和价值观的生活。最怕的事情是，在这样自己都不愿认可的生活中，磨平了棱角。\r\n\r\n积极争取想要的一切。我不想泡心灵鸡汤，因为我只是想说那些小事。就像你想要“一台大屏幕的显示器”这样的事情一样，如果它当然可以大大地提高你的工作品质，没有什么太明显不过的迹象阻挠你，为什么不争取一下？会失败还是成功？至少争取过了，不会有一点遗憾。我有一位欧洲的同事，它给公司的后勤部门提了不少意见建议，于是我们有了咖啡机、饮料有了更多的选品，灯管坏了能得到及时修理。还有一件小事，我的同事在飞机上被冷气吹得不舒服，提出来，没费多少口舌，得到了五千个里程的补偿。如果不屑去做、无所谓、有顾虑、懒得动弹，那就什么都不会有的。\r\n\r\n过酷一点的生活，还有自由的生活。你会有你自己的理解，比如西乔所说的“我在过着很奢侈的生活”，这绝不仅仅是只物质上（事实上她认为程序员还算是“收入能和付出成正比的群体”）。我可以以我自己为例，生活在北京但是我和我老婆远没有足够的钱，去买北京令我们方便和舒适的房子，那么我们就先不买，她每周都去练瑜伽，我每周都会打球，周末可以看电影、享受美食、学自己感兴趣的东西。我们还收养（主要是她在照顾）了两只无家可归的小狗（刚来的时候大概眼睛刚睁开，只能吃奶粉，现在已经会疯跑和到处乱啃了），等它们再大一点的时候可以把它们送到好一点的人家里去当宠物（如果你也在北京且感兴趣的话请联系我，邮件地址在右上角“关于四火”里有），我觉得这很酷。','c7','a19'),(20,'电脑 adb connect IP 连接不上手机解决方案','0','2013-06-19 21:08:00','2013-06-19 21:08:00','这一段时间使用电脑上面的adb connect IP ，想要连接手机，拷贝个小说，安装个应用不用数据线，居然死活连接不上\r\n\r\n昨晚突然看到一个文章说是有可能是端口被占用了\r\n\r\n所以今天我就下载了一个\r\n\r\n超级终端(better terminal emulator pro)     apk安装到手机上\r\n\r\n在shell的界面下，输入如下命令：\r\n\r\n \r\n\r\nsetprop   service.adb.tcp.port   5555\r\n\r\nstop adbd\r\n\r\nstart adbd\r\n\r\n关闭后，重新在电脑上面链接\r\n\r\n啊哈！搞定！','c3','a20'),(21,'Android基础——Fragment控制切换多个页面','0','2013-08-19 15:01:00','2013-08-19 15:01:00','今天接着上一篇文章，讲解一下Fragment的控制，主要是切换View和页面替换等操作。还有就是如何获取Fragment的管理对象，以及与Activity的通信方式。\r\n （PS：新建的Q_Q_群，有兴趣可以加入一起讨论：Android群：322599434）\r\n \r\n1、管理Fragment\r\n要在activity中管理fragment,需要使用FragmentManager. 通过调用activity的getFragmentManager()取得它的实例.\r\n可以通过FragmentManager做一些事情, 包括: 使用findFragmentById()(用于在activity layout中提供一个UI的fragment)或findFragmentByTag()(适用于有或没有UI的fragment)获取activity中存在的fragment。\r\n将fragment从后台堆栈中弹出, 使用 popBackStack() (模拟用户按下BACK 命令)。\r\n使用addOnBackStackChangeListener()注册一个监听后台堆栈变化的listener。\r\n \r\n2、处理Fragment事务\r\n关于在activity中使用fragment的很强的一个特性是：根据用户的交互情况,对fragment进行添加、移除、替换以及执行其他动作。提交给activity的每一套变化被称为一个事务，可以使用在FragmentTransaction中的 API 处理。我们也可以保存每一个事务到一个activity管理的backstack，允许用户经由fragment的变化往回导航(类似于通过 activity往后导航)。\r\n从 FragmentManager 获得一个FragmentTransaction实例：\r\nFragmentManager fragmentManager =getFragmentManager();\r\nFragmentTransaction fragmentTransaction =fragmentManager.beginTransaction();\r\n每一个事务都是同时要执行的一套变化。可以在一个给定的事务中设置你想执行的所有变化,使用诸如 add()、remove()和 replace()。然后, 要给activity应用事务，必须调用 commit()。\r\n在调用commit()之前，你可能想调用 addToBackStack()，将事务添加到一个fragment事务的backstack。这个back stack由activity管理， 并允许用户通过按下 BACK按键返回到前一个fragment状态。\r\n//创建修改实例\r\nFragment newFragment = newExampleFragment();\r\nFragmentTransaction transaction =getFragmentManager().beginTransaction();\r\n// Replace whatever is in thefragment_container view with this fragment,\r\n// and add the transaction to the backstack\r\ntransaction.replace(R.id.fragment_container,newFragment);\r\ntransaction.addToBackStack(null);\r\n//提交修改\r\ntransaction.commit();\r\n上面是如何将一个fragment替换为另一个，并在后台堆栈中保留之前的状态。在这个例子中，newFragment替换了当前layout容器中的由R.id.fragment_container标识的fragment。通过调用 addToBackStack()， replace事务被保存到back stack，因此用户可以回退事务，并通过按下BACK按键带回前一个fragment。\r\n    如果添加多个变化到事务(例如add()或remove())并调用addToBackStack()，然后在你调用commit()之前的所有应用的变化会被作为一个单个事务添加到后台堆栈，BACK按键会将它们一起回退。添加变化到 FragmentTransaction的顺序不重要, 除以下例外: \r\n必须最后调用 commit()\r\n如果添加多个fragment到同一个容器, 那么添加的顺序决定了它们在view hierarchy中显示的顺序\r\n当执行一个移除fragment的事务时， 如果没有调用 addToBackStack()， 那么当事务提交后，那个fragment会被销毁，并且用户不能导航回到它。有鉴于此，当移除一个fragment时，如果调用了addToBackStack()， 那么fragment会被停止，如果用户导航回来，它将会被恢复。另外，对于每一个fragment事务，你可以应用一个事务动画，通过在提交事务之前调用setTransition()实现。\r\n调用 commit() 并不立即执行事务。恰恰相反，它将事务安排排期， 一旦准备好，就在activity的UI线程上运行(主线程)。如果有必要， 无论如何，你可以从你的UI线程调用executePendingTransactions()来立即执行由commit()提交的事务。但这么做通常不必要，除非事务是其他线程中的任务的一个从属。\r\n 警告:你只能在activity保存它的状态(当用户离开activity)之前使用commit()提交事务.\r\n \r\n \r\n3、与Activity通信\r\n         尽管Fragment被实现为一个独立于Activity的对象，并且可以在多个activity中使用,但一个给定的fragment实例是直接绑定到包含它的activity的。 特别的fragment可以使用 getActivity() 访问Activity实例， 并且容易地执行比如在activity layout中查找一个view的任务。如下面的代码：\r\nView listView =getActivity().findViewById(R.id.list);\r\n同样地,activity可以通过从FragmentManager获得一个到Fragment的引用来调用fragment中的方法，使用findFragmentById() 或 findFragmentByTag()。\r\nExampleFragment fragment =(ExampleFragment) getFragmentManager().findFragmentById(R.id.example_fragment);\r\n \r\n4、总结\r\n最后需要说一下Fragment的例子，Android官方已经提供了Fragment的各种使用的Demo例子，在我们SDK下面的API Demo里面就包含了Fragment的各种使用例子，需要看Demo的朋友，直接看API Demo那个程序就可以了，不用到处去找。里面分开不同功能，实现了不同的类。可以根据需要查看具体代码。','c3','a21'),(22,'Red Hat CEO：拥抱开源 拥抱克隆','0','2013-08-19 09:34:00','2013-08-19 09:34:00','摘要：多年以来，企业的数据中心一直在各种昂贵的硬件上运行着Unix操作系统，但随着时间的推移，Windows和Linux系统在市场份额上占据了一席之地，而Red Hat则赢得了更广阔的一片天地。那么成功的秘诀是什么？\r\n当许多公司都在为打击盗版时，Red Hat却拥抱其最顶级的克隆，CentOS。下面让我们一起来看下Red Hat是如何利用开源达到今天的地位的。\r\n\r\n\r\n\r\n想象一下，你的公司花了超过1亿美元来研发一款产品，而你的竞争对手却完美地克隆了这款产品，在许多人看来，这是非常不好甚至让人憎恨的行为。如果你是苹果公司，那么很有可能花时间和金钱来与之斗争，对产品进行维权。而如果你是Red Hat，你会拥抱它，正如Red Hat CEO Jim Whitehurst在一次采访中所描述的那样。\r\n\r\nUnix的替代者\r\n\r\n多年以来，企业的数据中心一直在各种昂贵的硬件上运行着Unix操作系统，但随着时间的推移，Windows和Linux系统在市场份额上占据了一席之地，而Red Hat则赢得了更广阔的一片天地。谈到这里不禁想问，成功的秘诀是什么？Windows和Linux的低成本与高附加值刚好代替Unix高昂的定价。\r\n\r\n暂且不谈Unix，有人会认为，下面进行厮杀的应该是Window和Linux了，实际上并非如此。正如Whitehurst所说，Red Hat与微软之间的确存在竞争，但一般来讲，IT决策都是建立于架构级别之上的，尤其是在拿Linux与Windows对比时。如今，企业架构较多地倾向Linux而非Windows，在十年前，或许是恰恰相反的。如今，企业版的Linux已经成为IT决策的一部分。\r\n\r\nWhitehurst说道，企业在发展的道路上肯定会出现新的工作负载，但它们大多数都是基于Linux的。基于此，Whitehurst对来自微软的威胁并不担心，因为他们已经和VMware在构建未来新的数据中心策略。\r\n\r\n头号公敌VMware\r\n\r\nSun公司曾是Unix系统的最大供应商，但已被Oracle收购。如今Red Hat的头号公敌则是VMware。原因很简单：两家公司对未来的云计算发展有着非常相似的展望，尽管他们提供云服务的途径有所不同。Whitehurst表示：“如果你去仔细思考现在是谁在定义云计算架构，就会发现实际上就是我们两家公司，但VMware走的是自主创新模式，即封闭模式，而我们则是开放模式。”\r\n\r\n如何开放？开放并不意味着Red Hat要与VMware的开源产品进行战斗，厮杀，相反，而是拥抱克隆，比如CentOS。\r\n\r\n虽然越来越多的产品建立在开源基础之上，但是很少有人理解开源软件业务的实际内涵。就拿Red Hat来说，它开发出了非常流行的Red Hat Enterprise Linux (RHEL) 操作系统，但是由于Linux是由社区共同开发的操作系统，所以必须把Linux的源码对外开放（Red Hat对支付费用的客户提供一些技术服务支持）这就为像CentOS的厂商铺平了道路。\r\n\r\n拥抱寄生虫\r\n\r\n虽然像微软等公司经常拿CentOS对Red Hat构成威胁来进行言论，但Whitehurst认为，CentOS在他们的生态系统中扮演着非常重要的角色：\r\n\r\nCentOS之所以是RHEL生态系统中的重要一员，它在间接让用户关注RHEL生态系统，让更多的人接触和认识Linux，而Linux并没有办法强迫任何人来使用它。所以，从眼前来看，CentOS使得Red Hat公司损失了一些收入，但从长远来看，CentOS在构建Red Hat Linux生态中扮演了一个很重要的角色。\r\n与Ubuntu的主要供应商如SuSE或Canonical比起来，SuSE等厂商常会提供比RHEL廉价的售价给客户，但大多数仍然倾向于选择拥有相同代码的RHEL和CentOS，换句话说，只有Red Hat才能给业界提供领先的Linux服务器操作系统，同样也有免费的产品提供。微软在很久以前就默认了这种现象：虽然该公司花费巨资打击盗版，但比尔·盖茨在1998年曾指出，Windows系统在中国的非法克隆现象另一方面也增加了Windows的市场份额。\r\n\r\nRed Hat的销售人员并不爱与山寨竞争，但是现实是，一些厂商通过使用CentOS服务器来进行研发和测试来降低生产成本，从而增加收入。换句话说，CentOS并没有给RHEL降低价格，而是提供了更多的价格标杆。\r\n\r\n拥抱开发者\r\n\r\n按理说，在一些关键领域，CentOS并未给Red Hat和开发商带来多少帮助，开发商追寻最新最好的技术，而Red Hat的客户已与业务部门有着多年的交情，他们想要稳定及可控的软件，而克隆RHEL的CentOS并未吸引开发商。\r\n\r\n目前，Red Hat正在尝试一些不同的东西，Red Hat软件集合，包括包括Web/动态编程语言、数据库、开发工具等。基本上，这些集合可以帮助开发者紧跟RHEL发展轨道。正如Whitehurst告诉大家的一样，该集合是Red Hat拥抱开发者和保持吸引力的一种方式。这将会是一种非常有趣的方式，Red Hat在定义开放的数据中心上还有很长的路要走，但Red Hat正在正确的轨道上前行。','c4','a22'),(23,'裁员4千、总裁员人数超过7.5万，难掩思科锋芒','0','2013-08-20 11:50:00','2013-08-20 11:50:00','摘要：近年来思科的人员变动无疑广受关注，近日其更宣布即将解雇4000员工，总裁员人数将超过7.5万，思科正走在业务放缓的黑暗中，然而不乏曙光的是其数据中心业务收益增长迅速。\r\n近日，思科公布了其第4季度财政收益，内容中心是：需求变得愈加缓慢，公司准备解雇4000人员（总解雇人数将超过7.5万）。黑暗之中往往不乏曙光，而思科的曙光就是——在数据中心云业务领域进步凶猛。如果CFO Frank Calderoni发言属实，那么思科依然锋芒万丈。\r\n\r\n在一个电话会议中Frank对分析师说道：“数据中心业务涨势非常凶猛，认真的说，这将是明年我们增长最快的领域。”思科公布的数据中，数据中心部分的收益是5.93亿美元，对比第3季度（5.15亿美元）增长15%，同比去年第4（4.15亿美元）季度增长43%。\r\n\r\n \r\n\r\n该公司CEO John Chambers与华尔街分析师谈论收益时曾表示：“未来5年内，思科的数据中心收入都将超过20亿美元，每年同季度收益对比都将增加40%，并且呈持续增长。”更令人震惊的则是该公司已经大展拳脚的服务器业务，Chambers引以为荣的说：“我们很高兴能占据全球范围内X86 Blade市场的第二位，大约占20%的市场份额，这是许多同行在几年前不曾想到的。”\r\n\r\n在了解服务器对于数据中心的意义后，思科于2009年开启了数据中心业务，而当下的成功无疑证明这是个正确的选择。他们选择了一个完美的时机——鉴于机构往云技术及移动互联网的迁移，数据中心产业无疑得到了蓬勃发展。\r\n\r\n \r\n\r\nChambers的言论暗示了思科全球服务器业务的进一步势头。Framingham（市场研究公司）公布的数据显示，2013年第一季度，思科与Oracle及Fujitsu并列第4。互联网数据中心让思科的服务器收益占全球服务器收益市场份额的4.1%，约4.5亿美元。思科的成功归结于他们在服务器领域的豪赌，而这个时候，其它的传统同行想的都是重思业务或者是直接放弃服务器业务。\r\n\r\n思科表示表示，即使现在数据中心交换机需求非常旺盛，这仍然不只是服务器的问题。该公司开发与销售主管Robert Lloyd在回答一个问题时补充到：\r\n\r\n如果你聚焦数据中心交换机投资组合，不难发现Nexus组合做的非常好，而Nexus第1季度的增长超过20%。我们有一个非常好的创新流水线，我们现在已经着眼Nexus 6000，采用蔓延的趋势非常乐观。几周前，我们引进了7700，1个40及100-gig数据中心交换机，40-gig的接口用于兼容当下的7000。除下UCS方面，还有很多非常强大的组合。此外，我认为在架构及当下环境，我们在将来会发布更多以应用为核心的特性，对于我们发展的路线，我感觉非常满意。','c4','a23'),(24,' 技术之美[程序人生]我在IBM实习的日子','0','2013-08-19 00:34:00','2013-08-19 00:34:00','写这篇文章的时候，我已经在IBM正式工作了，看看上一篇博文的发布日期，才发现，我已经将近三个月没有更新博客了，多么惊人！为什么这么久？期间发生了很多事情。最重要的一件就是我大学毕业了！毕业的那么平淡，很多同学说，似乎一下子从学校出来，放下书本，略有不适应。而我却没有毕业的感觉，正如四年前一样，高中毕业，我同样没有毕业的感觉一样，对老师、同学的思念和不舍，总会在毕业以后才会涌现。\r\n\r\n	写本文的目的，主要是记录我在IBM实习的日子，也是我大学生活的最后一段时光。它是我人生道路上非常有价值也值得我一生回味的日子。我是在2012年12月28日正式入职的。按道理说，2013年毕业的同学，应该在2012年的8-11月份校招找工作的。而我却在12月份找了一份实习。原因很简单，在校招的过程中，我没有找到理想的工作。奔波了一两个月，拿到的offer也不怎么样，一气之下继续去找实习。经过了两次面试，通过了，在上海，做云计算方面的研发。当时自己非常的开心，终于找到了自己理想的企业以及理想的工作。但是，这只是个开始，因为12月份开始的实习，是基本没有转正的机会的，面试的时候，经理已经讲得很清楚，而我当时已经下定决心，我一定要好好努力，争取能留在IBM。所以在接下来的几个月，我心里顶着不少压力，因为如果没有转正，意味着在即将毕业的6月份，我需要再去找工作。没有办法，我只能选择向前，后面的结果证明，我的选择是正确的，我遇到了好的同事，遇到了好的Manager，在我最后找工作的时候，他们给予我最大的帮助，感谢他们！\r\n\r\n	IBM是个很有历史的公司，有很完善的规章制度，之前我很难用一句话来形容IBM到底是什么样子的，后来进了IBM，我还是找不到一句话，来很好的描述IBM。直到一天，有个朋友听说我在IBM上班，他说，他一直认为IBM是世界上最伟大的公司，这句话，震惊了我！描述了长久以来我心里的一个感觉。它很恰当，也很准确。IBM的软硬件都处于世界的前列，有非常庞大的业务体系及服务范围，这都是其他公司无法与其媲美的！而且历经百年的大企业，在公司的制度和企业文化方面有相当丰富的积累。\r\n\r\n	还是说说重点，谈下我实习的感受吧。每个新的实习生，都会有一个mentor来带，包括刚进来适应新环境，办理相关手续，以致于后面做项目时分配task，大多数实习生都会跟着mentor做同样的project。一般适应期2周到一个月不等，因人而异，能力强的，更快一点加入项目。刚开始都是以学习为主，mentor会让你看很多和项目相关的资料，定期的检验下你的进度，学习的程度，有的会让你share一下，讲给你的同事听。总体来说一个目的，让你尽快掌握工作需要的知识，尽快上手干活。\r\n\r\n	要有很强的学习能力。大家对于在校学生或者应届生的期望不会太高，因为作为学生，在校期间不大可能做多么高水准的项目，所以即便项目经验为零也没有关系，公司看中的是你的潜质以及学习能力。IBM本身就有很多软件产品，像DB2，Was等等，而且大多数不管是新研发还是老项目，都要和这些自己的软件捆绑，所以，你需要有很强的学习能力，能快速掌握项目需要的东西。我们之前做云计算，因为是做PaaS平台方面的研发，所以会用到很多的东西，各种语言，各种DB，各种server，虽然大多数不需要深入理解，但是基本了解还是必须的。考验的就是学习能力（Quick Learning Ability）。在IBM，用的最多的语言是Java，IBM有自己的JDK，所以想来IBM实习的TX，一定要把Java学好，学精。\r\n\r\n	要具备良好的解决问题的能力。项目中遇到问题是很常见的事儿，需要我们有很强的解决问题的能力。这一点和经验有很大的关系。不论是查看系统日志，还是上网查，还是自己调试，还是请教高手，自己是需要有一个清晰的解决问题的思路的。IBM很看重一个人的problem solving skill，所以在面试的时候，一般都会问一个问题，就是：阐述一下你遇到过的一个问题，并且说明你是怎么解决的。\r\n\r\n	要有责任心。虽然作为一个实习生，似乎不需要有太多的责任，就算你不能按时完成task，老板也不会怪你，要怪也会找你的mentor。但是如果你想赢得同事们的信任，你必须要有强烈的责任心，你要适当的给自己一些压力，把自己当成正式工看待，视整个team的发展与你息息相关，这样才能快速成长。IBM很重视培养实习生，我之前实习的时候，一般leader会将任务细分成几个，不管是regular还是intern，谁想做哪一个自己挑，足够的公平和信任，只要你自己认为能够胜任，你可以挑选最有挑战的。当然，leader也会考虑，毕竟任务做不完是会影响整个project的进度的。\r\n\r\n	努力的工作。这一点在哪儿都适用，不管在哪个公司，leader都希望看到员工努力的工作。作为实习生，以学习为主，一定要努力一点儿，少说多做，多向他人学习，你的同事们都可以作为你的前辈，现在的他们，很可能就是你的将来，你应该在他们身上学到应有的素质，如何与人交往，如何解决问题，积累知识，对于一个实习生，有很多需要学习的地方。\r\n\r\n	学会沟通。作为程序员，越来越不会与人沟通是件常事，但我们不能觉得这很光荣，我们需要平时多注重这方面的培养，毕竟沟通是最基本的一个交流因素。在做项目的时候，我们不但经常与自己的同事沟通，有时因为项目的需要，我们需要与别的team的同事交流，以获取可能的帮助，有时通过电话，有时通过邮件，或者聊天，总之，不管用什么方式，我们需要尽可能的在短的时间内，将问题、需求描述清楚，这样对方才能给予我们准确的答复。\r\n	\r\n	快速、利索的完成每一个task。很多时候，我们的工作是以task为单位的，当领到新的任务后，我们一定要尽量在规定的时间内完成，如果不能及时完成，一定要说明原因，必要时寻求他人帮助，但是，千万不要一拖再拖，最后不了了之。这方面体现我们工作的态度，不能按时完成任务，一方面是能力的体现，另一方面会让人觉得你很不靠谱。IBM不鼓励员工加班，最理想的情况就是我们能高效的工作，争取在一天8个小时之内，将该做的工作做完。当然如果项目紧急，该加的时候还是需要加的。\r\n\r\n	在IBM感触很深的还有一点，就是关于实习生的招聘，进来之前不知道。大多时候都是内推，像在上海的话，有很多南大，上海交大，复旦，浙大的同事，在宁波，有很多浙大软院的同事，其实IBM有很大的实习生需求，很多都是team的同事推荐，或者发往那些名校的BBS，QQ群，做技术的话，现在很少有本科生，90%以上都是研究生。在IBM实习，可以学到很多东西，对于初出茅庐的学生，通过半年到一年的实习，可以很快的走上职业化的道路。\r\n\r\n	说了这么多，也该收尾了，以后想到什么再来补充，现在笔者已在宁波入职，但是很怀念在上海的日子！上海是个很美的城市，我很喜欢。','c5','a24'),(25,'学生信息管理系统“重复设置”问题','0','2013-08-19 10:33:00','2013-08-19 10:33:00','在做学生管理系统的时候，在设置年级课程信息的窗体中，每点击“设置课程”键，就会重复添加一次，不管该课程是否存在。而添加键也是存在这样的问题。这个问题该怎样解决？\r\n   就这个问题，我从listbox的属性入手，不要求里listbox的属性都要求你都知道。最起码这个用到的都要知道。在这里我觉得就像米老师说的，在我们学习vb入门的时候，我们不必所有的都弄懂，所有的都记住。我们只有知道有这样的一个类，它叫listbox，当我们遇到它的时候，查就可以了。毕竟，百度比我们的记忆好的多，知道的多。\r\n   要解决这个问题，listbox的additem、removeitem方法要了解，listindex和listcount属性必须知道。\r\n   简单一点说：additem是将项添加到列表框中的。\r\n             removeitem是将项从列表框中删除的。\r\n            listindex返回的是列表框list中当前选择项目的索引号码。\r\n            listcount返回的是列表框list中项目总数。\r\n   知道了这些，那么就看代码很清楚了：\r\n \r\n[vb] view plaincopyprint?\r\n<span style=\"font-family:KaiTi_GB2312;font-size:24px;\"><strong>Private Sub cmdSet_Click()                                      \'“设置课程”按钮  \r\n    Dim mrc As ADODB.Recordset  \r\n    Dim txtSQL As String  \r\n    Dim MsgText As String  \r\n                                                                \'使控件有效  \r\n    listAllcourse.Enabled = True  \r\n    listSelectcourse.Enabled = True  \r\n    cmdModify.Enabled = True  \r\n      \r\n    txtSQL = \"select * from course_Info \"  \r\n    Set mrc = ExecuteSQL(txtSQL, MsgText)  \r\n                                                                \'显示所有课程  \r\n    While (mrc.EOF = False)                                     \'遍历记录方法2  \r\n        listAllcourse.AddItem mrc.Fields(1)  \r\n        mrc.MoveNext  \r\n    Wend  \r\n    mrc.Close  \r\n      \r\n    flagSet = True  \r\nEnd Sub</strong></span>  \r\n\r\n  这段代码的运行结果是：\r\n  \r\n  那么我们要修改它，就要从while wend 段中修改，具体方法：\r\n \r\n[vb] view plaincopyprint?\r\n<span style=\"font-family:KaiTi_GB2312;font-size:24px;\"><strong>While (mrc.EOF = False)                                    \'遍历记录方法2  \r\n        If listAllcourse.ListCount <> mrc.RecordCount Then  \r\n        listAllcourse.AddItem mrc.Fields(1)  \r\n        End If  \r\n        mrc.MoveNext  \r\nWend  \r\nmrc.Close  \r\n  \r\n</strong></span>   \r\n\r\n \r\n   \r\n  另外，还有添加键的设置，原代码是这样的：\r\n[vb] view plaincopyprint?\r\n<span style=\"font-family:KaiTi_GB2312;font-size:24px;\"><strong>Private Sub cmdAdd_Click()  \r\n    If listAllcourse.ListIndex <> -1 Then  \r\n        listSelectcourse.AddItem listAllcourse.List(listAllcourse.ListIndex)  \r\n    End If  \r\nEnd Sub</strong></span>  \r\n\r\n   运行结果：\r\n  \r\n  改过之后是这样的：\r\n \r\n[vb] view plaincopyprint?\r\n<span style=\"font-family:KaiTi_GB2312;font-size:24px;\"><strong>Private Sub cmdAdd_Click()  \r\n    Dim I As Integer  \r\n      \r\n    If listAllcourse.ListIndex <> -1 Then  \r\n          \r\n       If listSelectcourse.ListCount = 0 Then  \r\n             listSelectcourse.AddItem listAllcourse.List(listAllcourse.ListIndex)  \r\n       End If  \r\n          \r\n        For I = 0 To listSelectcourse.ListCount - 1  \r\n            If listSelectcourse.List(I) = listAllcourse.List(listAllcourse.ListIndex) Then  \r\n                Exit Sub  \r\n            End If  \r\n        Next  \r\n            listSelectcourse.AddItem listAllcourse.List(listAllcourse.ListIndex)  \r\n          \r\n    End If  \r\nEnd Sub</strong></span>  \r\n\r\n  里面涉及到一些逻辑问题，可以用F8键，进行调试，这样，你就知道，你的哪一步错了。\r\n  我个人认为：改正这个错误，不单单是锻炼我们调试能力和对list类的认识，更重要的是我们的一种学习习惯问题，道理就是在我们学习vb入门的时候，我们不必所有的都弄懂，所有的都记住。我们只有知道有这样的一个类，它叫listbox，当我们遇到它的时候，查就可以了。毕竟，百度比我们的记忆好的多，知道的多。','c5','a25'),(26,'行动下移篇之——aspnetpager分页控件','0','2013-08-19 08:11:00','2013-08-19 08:11:00','概述\r\n        在对网页上的记录进行分页显示时，一般用到两种方式，分别是假分页和真分页。假分页就是从数据库中取出所有记录然后再进行分页；而真分页相对来说就简单多了，真分页只需要从数据库中取出当前页需要显示的记录即可。如果你的记录数据量比较小，用哪种方法都可以，如果记录数据量特别大，这时就需要用我们的真分页来提高我们的效率。\r\n       在这里我们用aspnetpager分页控件来实现我们的真分页。aspnetpager分页控件下载的地址是：http://www.webdiyer.com/Controls/AspNetPager/Downloads\r\n \r\n实现过程\r\n         在正式真分页实现之前，我们还需要说明一点，我们的aspnetpager将分页功能完成后还需要一个绑定数据的控件与之配合，我这里采用的是GridView控件，关于GridView控件本身也可以实现分页功能，但它属于假分页，实现起来也比较简单只需要设置两个属性（AollowPaging和PageSize）即可完成，我们就不赘余了，现在进入我们的实现过程。\r\n \r\n 1.添加AspNetPager控件\r\n     在我们vs的工具箱——右击——选择项——浏览——选择，选择完后系统会自动添加控件，到此我们该控件就添加进工具箱了，接下来就像一般控件一样拉到我们添加的页面就可。\r\n\r\n\r\n \r\n\r\n \r\n\r\n \r\n\r\n \r\n2.实现代码\r\n    我是采用三层架构并且利用我们的存储过程实现的我们分页显示的功能，具体步骤包括：\r\n         a.建立存储过程查询语句\r\n         b.数据层进行数据查询\r\n         c.前台代码调用\r\n \r\na.建立存储过程查询语句\r\n    首先我们要先从数据库查询所要显示的记录，我是采用存储过程实现的这个功能，下面这就是我们存储过程的代码：\r\n[sql] view plaincopyprint?\r\nset ANSI_NULLS ON  \r\nsetQUOTED_IDENTIFIER ON  \r\ngo  \r\n   \r\n--=============================================  \r\n--Author:        张文康  \r\n-- Create date:2013-8-7  \r\n--Description:        按页查询新闻  \r\n--=============================================  \r\nALTER PROCEDURE[dbo].[news_selectByPage]  \r\n@startIndex  int,  \r\n@endIndex int  \r\nAS  \r\nBEGIN  \r\nwith temptbl as (  \r\nSELECT ROW_NUMBER()OVER (ORDER BY id desc)AS Row, * from news )  \r\nSELECT * FROMtemptbl where Row between @startIndex and @endIndex  \r\nEND  \r\n\r\n\r\n \r\nb.数据层进行数据查询\r\n \r\nDAL层：\r\n      \r\n[csharp] view plaincopyprint?\r\n #region （有参数查询）按页查询，根据每页显示记录数  \r\n        /// <summary>  \r\n        /// 按页查询，根据每页显示记录数  \r\n        /// </summary>  \r\n        /// <paramname=\"startIndex\">该页开始记录数</param>  \r\n        /// <paramname=\"endIndex\">该页结束记录数</param>  \r\n        /// <returns></returns>  \r\n        public DataTable SelectByPage(intstartIndex, int endIndex)  \r\n        {  \r\n            DataTable dt = new DataTable();  \r\n            string cmdText =\"news_selectByPage\";  \r\n            SqlParameter[] paras = newSqlParameter[]{  \r\n                new SqlParameter(\"@startIndex\",startIndex ),  \r\n                 new SqlParameter(\"@endIndex\",endIndex )  \r\n   \r\n            };  \r\n            dt =sqlhelper.ExecuteQuery(cmdText, paras, CommandType.StoredProcedure);  \r\n   \r\n            return dt;  \r\n        }  \r\n   \r\n  \r\nSQLHlper  \r\n        #region 该方法执行传入的带参数的SQL查询语句或存储过程  \r\n        /// <summary>  \r\n        /// 该方法执行传入的带参数的SQL查询语句或存储过程  \r\n        /// </summary>  \r\n        /// <paramname=\"cmdText\">带参数的SQL查询语句或存储过程</param>  \r\n        /// <paramname=\"paras\">参数集合</param>  \r\n        /// <paramname=\"ct\">命令类型</param>  \r\n        ///<returns>查询数据表</returns>  \r\n        public DataTable ExecuteQuery(stringcmdText, SqlParameter[] paras, CommandType ct)  \r\n        {  \r\n            dt = new DataTable();  \r\n            cmd = new SqlCommand(cmdText,GetConn());  \r\n            cmd.CommandType = ct;  \r\n            cmd.Parameters.AddRange(paras);  \r\n   \r\n   \r\n            //比try catch 更好关闭数据源的处理  \r\n            using (sdr =cmd.ExecuteReader(CommandBehavior.CloseConnection))  \r\n            {  \r\n                dt.Load(sdr);  \r\n            }  \r\n   \r\n            //sdr.Close();  \r\n            //conn.Close(}  \r\n   \r\n            return dt;  \r\n        }  \r\n  \r\n        #endregion  \r\n\r\n \r\nc.前台代码调用\r\n \r\n[csharp] view plaincopyprint?\r\nusing System;  \r\nusingSystem.Collections.Generic;  \r\nusing System.Linq;  \r\nusing System.Web;  \r\nusing System.Web.UI;  \r\nusingSystem.Web.UI.WebControls;  \r\nusing BLL;  \r\nusing System.Data;  \r\n   \r\nnamespace Web  \r\n{  \r\n    public partial class test :System.Web.UI.Page  \r\n    {  \r\n        protected void Page_Load(object sender,EventArgs e)  \r\n        {  \r\n            if (!Page.IsPostBack)  \r\n            {  \r\n                //查询总新闻条数  \r\n                DataTable dt = newNewsManage().SelectAll();  \r\n                int titleCount = dt.Rows.Count;  \r\n                anp.RecordCount = titleCount;  \r\n                //进行显示  \r\n                BindNews();  \r\n            }  \r\n            else  \r\n            {  \r\n                BindNews();  \r\n            }  \r\n        }  \r\n   \r\n        //分页控件显示该页记录数  \r\n        protected voidAspNetPager1_PageChanged(object sender, EventArgs e)  \r\n        {  \r\n            //通过换页显示记录  \r\n            BindNews();  \r\n           Response.Write(\"开始记录数：\"+anp.StartRecordIndex+\"<br>结束记录数\"+anp.EndRecordIndex);  \r\n        }  \r\n   \r\n        //通过分页显示记录  \r\n        private void BindNews()  \r\n        {  \r\n            //定义该页开始记录数  \r\n            int start = anp.StartRecordIndex;  \r\n            //定义该页结束记录数  \r\n            int end = anp.EndRecordIndex;  \r\n            //绑定新闻列表  \r\n            DataTable dt = newNewsManage().SelectByPage(start, end);  \r\n            GridView1.DataSource = dt;  \r\n            GridView1.DataBind();  \r\n        }  \r\n    }  \r\n}  \r\n\r\n\r\n \r\n \r\n \r\n效果\r\n    仅仅是向大家展示我们具体的一个实现过程，所以页面样式这块我们没有进行设置，关于数据库的信息也是我临时输入的，仅仅是为了做实验用，关于AspNetPager控件的样式也有很多，大家可以自己设置。下面就是我们实现的效果图。\r\n\r\n\r\n\r\n \r\n \r\n总结\r\n    到这里呢，利用我们的AspNetPager控件就实现了我们的真分页的功能，它可以大大提高我们的网站或系统的处理效率。关于AspNetPager控件是我们牛腩视频里讲到的，不过它里面并没有具体实现，只是提了下这个控件的好处。我们在平常学习中就是要发扬这种行动下移的风格，它提到了，我们就要实现，要跟自己较真。','c5','a26'),(27,'LINUX下把多行文件合并成一行，并组装成SQL','0','2013-08-20 09:25:00','2013-08-20 09:25:00','先说一下适用的场景，市场部那边希望看到某些商品中“黄牛”用户的活动情况，以及“黄牛”使用代金券的情况，然后发一个excel文件过来，拿到文件先复制到notepad++中，格式类似：\r\n\r\nid name  price\r\n1 name1  price1\r\n2 name2  price2\r\n3 name3  price3\r\n4 name4  price4\r\n5 name5  price5\r\n6 name6  price6\r\n7 name7  price7\r\n8 name8  price8\r\n9 name9  price9\r\n查询的时候根据ID查询，所以要把所有的ID组织到一行中，并写成(1,2...,8,9)的格式，这需要做如下件事：\r\n\r\n第一，删除第一行标题，sed \'1d\' ids.txt  ；\r\n\r\n第二，只显示第一列， awk -F\'\\t\' \'{print $1}\'  ；\r\n\r\n第三，把第一列以逗号分隔，tr \'\\n\' \',\' ；\r\n\r\n第四，把第三步中的结果前后加上左右括号，sed \'s/^/(/\'。\r\n\r\n把这四步组在一起，执行：sed \'1d\' ids.txt | awk -F\'\\t\' \'{print $1}\' | tr \'\\n\' \',\' | sed \'s/,$/);/\' | sed \'s/^/(/\' > ok.txt\r\n\r\n就得到了(1,2,3,4,5,6,7,8,9);\r\n\r\n然后再写个sql和这个文件拼接上就OK了。此处对于数据量小的时候效果不明显，当处理几千万数据，一个文本有几个G的时候，\r\n\r\nLINUX强大的处理文本的功能就显示出来了。','c6','a27'),(28,'项目说事——信不信反正我信了（合作开发总结之文档）','0','2013-08-19 08:40:00','2013-08-19 08:40:00','信不信反正我信了。这句话让我很无耐啊，是啊经历过合作开发的程序猿应该都有着同感——无耐。项目开发应该是件高兴的事，挣钱嘛、工作经验啊谁不高兴，可是问题又来了，以前只是个人开发项目啊，文档好歹写写，图好歹画画，自己能看懂就得了，最主要是软件赶快写代码，把软件设计完成就可以万事大吉了。饿，想的倒美，项目开发哪有那么简单，每个环节都要精雕细琢，因为现在是合作开发，不是你个人的项目，要知道你好坏谁管啊，最主要是你这个枢纽，中间环节一定要做好，上有项目经理下有软件代码，你要兼顾哪个？\r\n   有人跳出来说了，那当然是项目经理喽，项目经理和小菜的命运息息相关，要多和项目经理交流交流，让他给我分个轻点的活，这样项目开发起来简单小菜负责的那部分也能漂亮的完成。饿，典型的小人形象。要知道合作开发哪一部分的内容都不简单啊，想要偷懒还不如退出项目组。可恶，为了能得到工作经验，当然更要为了小菜的Money，要硬着头皮上了。\r\n一、可行性分析\r\n   开始要对软件做需求分析，啊？你把可行性分析放到哪儿去做啦，要做完软件在写吗，要不你试试吧，软件开发完后再写可行性文档。有你这么做的吗，开发完后在编写可行性文档，有木有啊，软件做完了再给客户一个可行性文档，说这个软件确实可行，瞧我们已经开发出来啦，您要不用用看看。噗，我喷出来了，喝的水喷出来啦。当然不能这么写啦，软件开发伊始就应该进行可行性分析，生成可行性分析文档，虽然这个文档在现在的开发过程中可以不写，但是对于真正项目开发的文档来说，他并不是不写，只是这部分内容可能集成到其它文档内了，另一方面对于现阶段的我们来说这部分的文档也不是程序猿该考虑的事，这部分文档应该属于公司上层领导编写，至少也应该是项目经理的级别。当然对于我们这种需求已经很明确的小项目来说，这个文档就可以不用写了，直接跳到需求分析吧。\r\n二、需求分析\r\n   到了需求分析，小菜摸摸大脑心想需求分析我写过没有啊，似乎好像确实写过（有木有啊这么多形容词），最后拍拍脑门，啊，这个要写（这个真要写）。就算是需求已经很明确的软件，我们也要写，因为这个文档更是桥梁作用，上连接着客户（那是上帝啊）、老板，下兼顾着设计人员、编码人员，这部分文档一定要写好啊。于是之旗帜飘扬，信心满满、敲着锣打着鼓的编写起来了。这边描述、描述软件的功能，那边说说软件设备的支持，接口的定义，中间再说说用户的特点，描述描述软件的一些特性，输入输出的要求，就差不多了吧。似乎好像又很简单的样子啊，恩，是的啊。这部分说简单也简单，说难也很难。最主要是要把软件描述清楚，客户看到文档就知道软件是不是符合自己的要求，是否拥有自己想要的功能，这部分最好也能够把系统的数据结构描述一番，建立数据库的物理模型以便能在以后环节中设计出完美的数据库。啊，当然了，如果这部分写详细了，那么下面的概要设计说明书就很简单了。\r\n   说和做是两码事，需求分析文档在悄无声息中写完了，经过验证小菜写的需求文档还是有说服力的，老板看了后说，恩，写的不错，拿着去让客户看下，看看软件是否符合他们的要求。说完后，小菜顿时精神气爽，全身充满了力量，小菜明白这是老板对小菜的无比信任。人逢喜事精神爽啊，下班时小菜一路哼着小曲一路狂奔到家，等到了家后摸摸自己的口袋，差点没哭出来，有木有啊房屋钥匙没带。\r\n   为了赶快完成上级交代给的任务，小菜第二天就拿着文档去找客户，客户看到了文档后高兴的拍拍小菜的肩膀说，恩，不错我要的就是这个东西，赶快做吧我们着急用。得到客户的认可后，小菜第一时间报告给了上司，说客户对需求很满意，我们连夜加班还是值得的。老板听后笑了笑，“色眯眯”的对小菜说，好的小菜，去做吧，要快哦客户着急用呢。小菜听到后是神清气爽，顿时感觉无比的清爽，但心里似乎又有点沉重，又有一座大山压在了小菜的背上啊（上面的故事纯属虚构，使用需求文档和客户沟通时会有很多问题，上面只是为了总结需要，不涉及到故事情节）。\r\n三、概要设计\r\n   要写概要设计说明书了，小菜拍拍自己的脑瓜说，这个还写不写啊，需求已经很明确了，各阶段的设计也很清晰，要不就不用写了？为什么我顿时有种想揍小菜的感觉，不要偷懒好不好，概要设计当然要写啦，需求虽然明确，但是概要设计的内容和需求分析是不一样的。概要设计主要是规划整个系统的总体组成结构、子系统或模块边界、协作方式、数据分布、部署模型等内容，把系统简单化，对系统的内部结构及外部结构进行分析，设计出数据模型，架设好数据库系统，可以说它在需求文档上更进一步对系统进行了描述，设计出系统主要的包图结构，数据要求，数据结构。这部分的文档读者广泛系统架构师、系统编码人员等都有可能会看这部分内容。可以说概要设计文档是连接具体（客户对系统的描述）和抽象（系统本身）的一座桥梁。哦，好吧，小菜决定写啦。\r\n   对于概要设计文档小菜知道的还不是很多，不过经过小菜爬山涉水、翻山越岭这番折腾后，概要设计文档还是很圆满的写完了（这中间的细节就不细说了，概要设计的基本要求上面已经有说明）。写完了概要设计小菜终于舒了一口气，不过要想休息还早着呢。概要设计完了要编写详细设计，这时候才是真正考验小菜的时候，小菜挠挠脑袋说，好吧。\r\n四、详细设计\r\n   又一座大山压在了小菜身上，这次这座大山不比从前，这次要把整个软件描述一遍啊，我的天，现在小菜对这个软件的设计还没有清醒的认识，以前的文档不需要太多的专业知识，按照规范格式写就没问题啊，现在肿么去写啊，更何况小菜以前就写过代码，没有画过流程图，没有研究过算法，更不懂怎么使用UML了，从哪里下手。啊，小菜幡然悔悟……我还是不当项目经理啦，乖乖的做我的程序猿吧。\r\n   哎，小菜啊小菜，这次山穷水尽了吧，谁让你以前不好好学来着，现在知道文档难写了吧。还是我来告诉你详细说明文档书写规范吧，详细说明文档在概要设计基础上更进一步，首先要阐明系统的总体设计，给出软件系统的结构图，对类图进行详细说明；其次并对程序进行详细的描述，这部分最好逐个模块给出有关系统的功能、性能、输入和输出，并详细说明模块所用的算法，内部结构有了，还要对程序逻辑进行详细的描述，详细描述模块实现的算法，可采用：标准流程图；PDL语言；N-S图；判定表等描述算法的图表。当然还要考虑接口及后期的测试要点，要知道哪有这么容易编写啊。\r\n五、幡然悔悟\r\n   小菜最后决定了，归隐山林做一个程序猿，但是好事似乎一直都和他无缘，信不信反正我信了，他不去惹事，但是坏事总是去招惹他。\r\n（以上故事纯属虚构，因为在合作开发中看到大多数人用几天时间就完成了前期几个文档的编写，虽然是编写完成了，但是在以后的开发中却遇到了很多问题，对于这种现象小小的吐下槽，并以一种幽默的方式来说下项目中前期几个文档编写的规范和要求，对合作开发中的文档编写进行回顾。）','c6','a28'),(29,'Linux启动新进程的几种方法及比较','0','2013-08-20 00:15:00','2013-08-20 00:15:00','有时候，我们需要在自己的程序（进程）中启动另一个程序（进程）来帮助我们完成一些工作，那么我们需要怎么才能在自己的进程中启动其他的进程呢？在Linux中提供了不少的方法来实现这一点，下面就来介绍一个这些方法及它们之间的区别。\r\n\r\n一、system函数调用\r\nsystem函数的原型为：\r\n[cpp] view plaincopyprint?\r\n#include <stdlib.h>  \r\nint system (const char *string);  \r\n它的作用是，运行以字符串参数的形式传递给它的命令并等待该命令的完成。命令的执行情况就如同在shell中执行命令：sh -c string。如果无法启动shell来运行这个命令，system函数返回错误代码127；如果是其他错误，则返回-1。否则，system函数将返回该命令的退出码。\r\n\r\n注意：system函数调用用一个shell来启动想要执行的程序，所以可以把这个程序放到后台中执行，这里system函数调用会立即返回。\r\n\r\n可以先先下面的例子，源文件为new_ps_system.c，代码如下：\r\n[cpp] view plaincopyprint?\r\n#include <stdlib.h>  \r\n#include <stdio.h>  \r\n  \r\nint main()  \r\n{  \r\n    printf(\"Running ps with system\\n\");  \r\n    //ps进程结束后才返回，才能继续执行下面的代码  \r\n    system(\"ps au\");// 1  \r\n    printf(\"ps Done\\n\");  \r\n    exit(0);  \r\n}  \r\n该程序调用ps程序打印所有与本用户有关的进程，最后才打印ps Done。运行结果如下：\r\n\r\n\r\n\r\n如果把注释1的语句改为：system(\"ps au &\");则system函数立即返回，不用等待ps进程结束即可执行下面的代码。所以你看到的输出，ps Done可能并不是出现在最后一行，而是在中间。\r\n\r\n一般来说，使用system函数不是启动其他进程的理想手段，因为它必须用一个shell来启动需要的程序，即在启动程序之前需要先启动一个shell，而且对shell的环境的依赖也很大，因此使用system函数的效率不高。\r\n\r\n二、替换进程映像——使用exec系列函数\r\nexec系列函数由一组相关的函数组成，它们在进程的启动方式和程序参数的表达方式上各有不同。但是exec系列函数都有一个共同的工作方式，就是把当前进程替换为一个新进程，也就是说你可以使用exec函数将程序的执行从一个程序切换到另一个程序，在新的程序启动后，原来的程序就不再执行了,新进程由path或file参数指定。exec函数比system函数更有效。\r\n\r\nexec系列函数的类型为：\r\n[cpp] view plaincopyprint?\r\n#include <unistd.h>  \r\n  \r\nchar **environ;  \r\n  \r\nint execl (const char *path, const char *arg0, ..., (char*)0);  \r\nint execlp(const char *file, const char *arg0, ..., (char*)0);  \r\nint execle(const char *path, const char *arg0, ..., (char*)0, char *const envp[]);  \r\n  \r\nint execv (const char *path, char *const argv[]);  \r\nint execvp(cosnt char *file, char *const argv[]);  \r\nint execve(const char *path, char *const argv[], char *const envp[]);  \r\n这类函数可以分为两大类，execl、execlp和execle的参数是可变的，以一个空指针结束，而execv、execvp和execve的第二个参数是一个字符串数组，在调用新进程时，argv作为新进程的main函数的参数。而envp可作为新进程的环境变量,传递给新的进程，从而变量它可用的环境变量。\r\n\r\n承接上一个例子，如果想用exec系统函数来启动ps进程，则这6个不同的函数的调用语句为：\r\n注：arg0为程序的名字，所以在这个例子中全为ps。\r\n\r\n[cpp] view plaincopyprint?\r\nchar *const ps_envp[] = {\"PATH=/bin:usr/bin\", \"TERM=console\", 0};  \r\nchar *const ps_argv[] = {\"ps\", \"au\", 0};  \r\n  \r\nexecl(\"/bin/ps\", \"ps\", \"au\", 0);  \r\nexeclp(\"ps\", \"ps\", \"au\", 0);  \r\nexecle(\"/bin/ps\", \"ps\", \"au\", 0, ps_envp);  \r\n  \r\nexecv(\"/bin/ps\", ps_argv);  \r\nexecvp(\"ps\", ps_argv);  \r\nexecve(\"/bin/ps\", ps_argv, ps_envp);  \r\n下面我给出一个完整的例子，源文件名为new_ps_exec.c，代码如下：\r\n[cpp] view plaincopyprint?\r\n#include <unistd.h>  \r\n#include <stdio.h>  \r\n#include <stdlib.h>  \r\n  \r\nint main()  \r\n{  \r\n    printf(\"Running ps with execlp\\n\");  \r\n    execlp(\"ps\", \"ps\", \"au\", (char*)0);  \r\n    printf(\"ps Done\");  \r\n    exit(0);  \r\n}  \r\n运行结果如下：\r\n\r\n\r\n细心的话，可以发现，最后的ps Done并没有输出，这是偶然吗？并不是，因为我们并没有再一次返回到程序new_ps_exec.exe上，因为调用execlp函数时，new_ps_exec.exe进程被替换为ps进程，当ps进程结束后，整个程序就结束了，并没有回到原来的new_ps_exec.exe进程上，原本的进程new_ps_exec.exe不会再执行，所以语句printf(\"ps Done\");根本没有机会执行。\r\n\r\n注意，一般情况下，exec函数是不会返回的，除非发生错误返回-1，由exec启动的新进程继承了原进程的许多特性，在原进程中已打开的文件描述符在新进程中仍将保持打开，但任何在原进程中已打开的目录流都将在新进程中被关闭。\r\n\r\n三、复制进程映像——fork函数\r\n1、fork函数的应用\r\nexec调用用新的进程替换当前执行的进程，而我们也可以用fork来复制一个新的进程，新的进程几乎与原进程一模一样，执行的代码也完全相同，但新进程有自己的数据空间、环境和文件描述符。\r\n\r\nfork函数的原型为：\r\n[cpp] view plaincopyprint?\r\n#include <sys/type.h>  \r\n#include <unistd.h>  \r\n  \r\npid_t fork();  \r\n注：在父进程中，fork返回的是新的子进程的PID，子进程中的fork返回的是0，我们可以通过这一点来判断父进程和子进程，如果fork调用失败，它返回-1.\r\n\r\n继承上面的例子，下面我给出一个调用ps的例子，源文件名为new_ps_fork.c，代码如下：\r\n[cpp] view plaincopyprint?\r\n#include <unistd.h>  \r\n#include <sys/types.h>  \r\n#include <stdio.h>  \r\n#include <stdlib.h>  \r\n  \r\nint main()  \r\n{  \r\n    pid_t pid = fork();  \r\n    switch(pid)  \r\n    {  \r\n    case -1:  \r\n        perror(\"fork failed\");  \r\n        exit(1);  \r\n        break;  \r\n    case 0:  \r\n        //这是在子进程中，调用execlp切换为ps进程  \r\n        printf(\"\\n\");  \r\n        execlp(\"ps\", \"ps\", \"au\", 0);  \r\n        break;  \r\n    default:  \r\n        //这是在父进程中，输出相关提示信息  \r\n        printf(\"Parent, ps Done\\n\");  \r\n        break;  \r\n    }  \r\n    exit(0);  \r\n}  \r\n输出结果为：\r\n\r\n\r\n\r\n我们可以看到，之前在第二点中没有出现的ps Done是打印出来了，但是顺序却有点不对，这是因为，父进程先于子程序执行，所以先输出了Parent， ps Done，那有没有办法让它在子进程输出完之后再输出，当然有，就是用wait和waitpid函数。注意，一般情况下，父进程与子进程的生命周期是没有关系的，即便父进程退出了，子进程仍然可以正常运行。\r\n\r\n2、等待一个进程\r\nwait函数和waitpid函数的原型为：\r\n[cpp] view plaincopyprint?\r\n#include <sys/types.h>  \r\n#include <sys/wait.h>  \r\n  \r\npid_t wait(int *stat_loc);  \r\npid_t waitpid(pid_t pid, int *stat_loc, int options);  \r\nwait用于在父进程中调用，让父进程暂停执行等待子进程的结束，返回子进程的PID，如果stat_loc不是空指针，状态信息将被写入stat_loc指向的位置。\r\n\r\nwaitpid等待进程id为pid的子进程的结束（pid为-1，将返回任一子进程的信息），stat_loc参数的作用与wait函数相同，options用于改变waitpid的行为，其中有一个很重要的选项WNOHANG，它的作用是防止waippid调用者的执行挂起。如果子进程没有结束或意外终止，它返回0，否则返回子进程的pid。\r\n\r\n改变后的程序保存为源文件new_ps_fork2.c，代码如下：\r\n[cpp] view plaincopyprint?\r\n#include <unistd.h>  \r\n#include <sys/types.h>  \r\n#include <stdio.h>  \r\n#include <stdlib.h>  \r\n  \r\nint main()  \r\n{  \r\n    pid_t pid = fork();  \r\n    int stat = 0;  \r\n    switch(pid)  \r\n    {  \r\n    case -1:  \r\n        perror(\"fork failed\");  \r\n        exit(1);  \r\n        break;  \r\n    case 0:  \r\n        //这是在子进程中，调用execlp切换为ps进程  \r\n        printf(\"\\n\");  \r\n        execlp(\"ps\", \"ps\", \"au\", 0);  \r\n        break;  \r\n    default:  \r\n        //这是在父进程中，等待子进程结束并输出相关提示信息  \r\n        pid = wait(&stat);  \r\n        printf(\"Child has finished: PID = %d\\n\", pid);  \r\n        //检查子进程的退出状态  \r\n        if(WIFEXITED(stat))  \r\n            printf(\"Child exited with code %d\\n\", WEXITSTATUS(stat));  \r\n        else  \r\n            printf(\"Child terminated abnormally\\n\");  \r\n        printf(\"Parent, ps Done\\n\");  \r\n        break;  \r\n    }  \r\n    exit(0);  \r\n}  \r\n输出为：\r\n\r\n\r\n可以看到这次的输出终于正常了，Parent的输出也在子进程的输出之后。\r\n\r\n总结——三种启动新进程方法的比较\r\n首先是最简单的system函数，它需要启动新的shell并在新的shell是执行子进程，所以对环境的依赖较大，而且效率也不高。同时system函数要等待子进程的返回才能执行下面的语句。\r\n\r\nexec系统函数是用新的进程来替换原先的进程，效率较高，但是它不会返回到原先的进程，也就是说在exec函数后面的所以代码都不会被执行，除非exec调用失败。然而exec启动的新进程继承了原进程的许多特性，在原进程中已打开的文件描述符在新进程中仍将保持打开，但需要注意，任何在原进程中已打开的目录流都将在新进程中被关闭。\r\n\r\nfork则是用当前的进程来复制出一个新的进程，新进程与原进程一模一样，执行的代码也完全相同，但新进程有自己的数据空间、环境变量和文件描述符，我们通常根据fork函数的返回值来确定当前的进程是子进程还是父进程，即它并不像exec那样并不返回，而是返回一个pid_t的值用于判断，我们还可以继续执行fork后面的代码。感觉用fork与exec系列函数就能创建很多需的进程。','c7','a29'),(30,'C# 基础知识 (一).概念与思想篇','0','2013-08-20 01:46:00','2013-08-20 01:46:00','在C#中有一些我自己认为比较独特的知识点，这些知识点是我经常使用的知识，但对它们的了解还是比较少的，所以通过查找资料学习，总结了这些独特的知识点并简单叙述，第一篇主要是一些概念和思想方面的知识。（后面还有C#其他篇的文章）\r\n\r\n一.C#概念\r\nC#语言是从C和C++语言演变而来的，是微软创建的一门面向对象、运行在.NET Framework上的高级程序语言，是Windows的一个必要组件，包括一个称为公共语言运行时（common language runtime，CLR）的虚拟执行系统和一组统一的类库。（C#源文件扩展名为.cs）\r\n\r\nC#与Java有很多相似的地方:继承、接口、声明命名空间（using&import）、从Main入口点开始执行、源代码被编译成中间状态等。同时也有明显不同之处:C#借鉴了Delphi的与COM是直接集成的特点、它们所执行的平台也不相同，Java运行环境JRE（Java Runtime Environment），C#运行环境CLR（Common Language Runtime），且CLR支持多种语言；同时C#提供封箱装箱等方法。\r\n\r\n二.面向对象思想\r\n面向对象是将客观事物看做属性和行为的对象,通过抽象同一类对象的共同属性和行为,形成类。通过对类的继承和多态实现代码重用等。对象(Object)是类(Class)的一个实例(Instance),如果将对象比作房子，那么类就是房子的设计图（类中定义包括属性和方法）。\r\n\r\n面向对象的三个基本特征为:\r\n\r\n(1).封装:把客观事物封装成抽象的类，类中数据和方法只让可信类或对象操作，不可信的隐藏(内部细节)\r\n\r\n(2).继承:它可使用类的所有功能，无需重新编写原有类且对功能进行扩展\r\n\r\n(3).多态:一般类中定义的属性或行为,被特殊类继承后,可以具有不同的数据类型或表现不同的行为,各个类能表现不同的语义，实现的两种方法为覆盖和重载\r\n\r\n通过下面的例子来讲解面向对象：\r\n\r\n例1：让你编写一个计算长方体体积的程序，通常的思想是定义3个变量长=a,宽=b,高=c,体积v=a*b*c；而在面向对象思想中先创建一个长方体的类，在类中定义长宽高和体积，然后定义方法，在实例化使用。(C++代码)\r\n\r\n[csharp] view plaincopy\r\nclass Rect {  \r\npublic:  \r\n    void showArea(…);         //定义方法：计算长方体体积  \r\nprivate:  \r\n    float a,b,c,v;            //定义属性：长 宽 高 体积（私有成员）  \r\n}  \r\nvoid Rect::showArea(…) {…}  \r\n这样的好处是它是站在事物本身的角度去思考解决问题，如果上面采用面向过程定义函数的形式实现，当出现多个形状时，你需要对每一种形状都定义一种方法，而面向对象只需把这些形状的属性和方法抽象出来，更加方面的实现。\r\n\r\n值得注意的是，面向对象提供的是一种思想，而非仅仅是课本中的那点知识，很多时候我们仅仅是把使用了C++、C#或Java一门面向对象的语言，或者是定义了几个类、使用继承等知识就认为自己运用了面向对象（我就是这样的）；但我更认为面向对象是一种思想，一种更好的解决实际问题的方法。比如有这样一个问题：\r\n\r\n例2：为了方便儿童学习编程，X公司开发了一套Racing Car 模拟器，使用这个模拟器每个孩子都可以用一种简单的语言来控制一辆赛车，例如，right，left等。请设计一种简单的语言，给出它的语法，以及该语言的类图。\r\n\r\n这就是我们实际编程中联系到生活的问题，它涉及到了设计模式的相关知识，其中我采用的方法是“命名模式”实现的：客户端是定义Children和Car，请求者是Children发出的Right\\Left\\Up\\Down命令，接受实现者是Car执行Move()，抽象命令是上下左右的抽象接口，具体命令是Car的上下左右。我制作的类图如下：\r\n\r\n\r\n\r\n通过这个例子我不是想证明我采用命令模式和画的类图是否正确，我想阐述的想法是我们学习面向对象知识主要是用来解决实际生活中的问题，让它更加高效的解决问题和优化代码。在学习《设计模式》时老师就曾说过“模式是现成的，但实现方法要靠自己；同时，学习的时候要敢于否认自己以前很熟悉的套路，甚至经典套路，只要能更加高效正确的完成项目，你的模式就很可能就是经典。”所以，我才认为面向对象是一种思想，不是宏观的C语言就是面向过程，C++、C#就是面向对象。\r\n\r\n同时，面向对象思想要适应需求的变化，解决用户的实际需求，在设计时就要尽量考虑到变化，会涉及到抽象、封装变化（重点）、设计模式等知识。补充：C#中的对象都是System.Object的子类，即所有对象都继承System.Object，这样的好处是所有的对象都可以有公用的方法，如ToString()方法。\r\n\r\n三.总结\r\n上面的内容主要是我对C#基础知识的一些自己理解，很可能我理解思想是错误的，但我更希望提供一种自己的思想与大家分享。同时，由于知识有限，做的项目也少，可能理解有错误的地方或还没有理解更深层的地方，见谅！最后希望几十年后的自己也能像很多大神一样回过头来对年少时的自己写的这些博文做些更深入的分析，在根据那时的经历写出更优秀的阅历与大家分享更深刻的经验！鼓励自己与大家加油。','c7','a30'),(31,'刚子扯谈：微信即将过去式 易信流量全免','0','2013-08-20 08:34:00','2013-08-20 08:34:00','微信宕机：易信中出。今晚真热闹啊，微信会让我们以后变得脾气暴躁，原因就是网易玩了一把釜底抽薪，既上半年的两次 宕机后，微信今晚有挂了。\r\n如果哥告诫下它就是：既生微，何生易！易信今天在北京发布了盛大发布会，微信就宕了。而这个富二代就嗖嗖地已目前已上了App Store前三名。\r\n看来拼爹的年代比的不是谁用户量多、也不是谁有名，而是谁他爹有控制权。易信他爹有俩，中国电信，叔叔阿姨是中国移动和中国联通，他娘是网易，负责儿子的发展。儿子出生当天，必须得整点事，然后他爹把阻碍儿子降生的信号告诉了电信用户，然后电信的网络信令有一半给了份子，他叔和他阿姨为了表示友好，也送个礼物。然后他娘偷着乐了！\r\n以上为刚子扯谈段落；微信的真正体验来源于网络流量，命根子让人断了。\r\n结合中央台报道我做了以下：\r\n他爹为易信的通讯功能均提供免费：流量免费、短信免费、电话留言免费。\r\n——易信的使用不区分运营商。中国电信、中国联通和中国移动的手机用户均可以无限制的安装和使用；\r\n—流量费用免费。中国电信用户使用易信所产生的无线流量费用全免，包含易信调用的音乐、视频、图片服务，及各种官方插件。短视频、点歌台和图片分享可能会取代文本，成为群聊和朋友圈的主要内容；\r\n——在发送免费短信和电话留言时，并不需要添加为易信好友，直接调用通讯录选择联系人即可；\r\n——短信费用全免。易信用户之间聊天免费，如果接收方没有安装易信，易信仍然可用中国电信的短信网关找到并发送给接收方，短信费用照样免。本条适用于中国电信、中国联通和中国移动的所有手机用户。\r\n——电话留言费用全免。用易信可以给通讯录中的所有手机和固定电话发送免费语音留言，接收方如果没有接听，每隔一个小时，会收到一次呼叫提醒，并可以语音回复，这相当于将微信的语音对讲扩充到任意手机和电话用。同样，适用于包括中国电信、中国联通和中国移动的所有手机用户。\r\n在微信忙着解决信息过载时，易信回归通讯本身，据电信内部人士说：我们会把固话、录音留言、呼叫中心等各类业务以插件的方式在这个平台打通。而丁磊也有这样的表示，“我们要感谢腾讯，他们培养了一种巨大的、新的用户体验方式，就是可以对着手机讲话，以录音的方式传给大家，其实这种通讯方式的创新，没有他们的推动，需要很长的时间才能被培养出来。但是一旦普及了，就存在创新和优化的空间”。这些表态可以理解为，通讯将是易信未来一段时间内的产品基调，中国电信正在用易信这一款软件来接管它的所有通讯业务，并免费之。\r\n部分内容采编于虎嗅网，今晚新闻大肆宣传推广了这个小子，这小子火了。  ','c6','a31'),(32,'提高你的Java代码质量吧：避免基本类型数组转换列表陷阱（Arrays.asList()）','0','2013-08-20 09:07:00','2013-08-20 09:07:00','一、分析 \r\n我们在开发的过程中经常会使用Arrays和Collections这两个工具类在数组和列表之间转换。 \r\nArrays.asList()方法：输入一个变长参数，返回一个固定长度的列表。看源码： \r\n[plain] view plaincopy\r\npublic static<T> List<T> asList(T... a){   \r\n    return new ArrayList<T>(a);   \r\n}   \r\nasList方法输入的是一个泛型变长参数，我们知道基本类型是不能泛型化的，也就是说8个基本类型不能作为泛型参数，要想作为泛型化参数就必须使用其对应的包装类型。 \r\n二、场景 \r\n在使用Arrays虽然非常方便，但有时候会出现一些奇怪的问题，看如下代码： \r\n[plain] view plaincopy\r\npublic static void main(String[] args){   \r\n    int[] data = {1,2,3,4,5};   \r\n    List list = Arrays.asList(data);   \r\n    System.out.println(\"列表中的元素数量是：\" + list.size());   \r\n}   \r\n也许你会说，这很简单，list变量的元素数量当然是5。但是运行结果却是1。 \r\n由上分析得知，int基本类型是不能被泛型化，传入asList方法的。在Java中数组是一个对象，它是可以泛型化的，也就是说上面例子把int类型的数组作为了T的类型，所以在转换后在List中就只有一个类型为int数组的元素了。我们打印出来看看，代码如下： \r\n[plain] view plaincopy\r\npublic static void main(String[] args){   \r\n    int[] data = {1,2,3,4,5};   \r\n    List list = Arrays.asList(data);   \r\n    System.out.println(\"元素类型：\" + list.get(0).getClass());   \r\n    System.out.println(\"前后是否相等：\" + data.equals(list.get(0));   \r\n}   \r\n输出结果是： \r\n元素类型：class [I \r\n前后是否相等：true \r\n问题弄清楚了，修改方案也就有了，直接使用包装类型即可，代码如下： \r\n[plain] view plaincopy\r\npublic static void main(String[] args){   \r\n    Integer[] data = {1,2,3,4,5};   \r\n    List list = Arrays.asList(data);   \r\n    System.out.println(\"列表中的元素数量是：\"+ list.size());   \r\n}ﾠ   \r\n三、建议 \r\n原始类型数组不能作为asList的输入参数，否则会引起程序逻辑混乱。','c7','a32'),(33,'IP多播---C++实现','0','2013-08-20 13:01:00','2013-08-20 13:01:00','多播基础知识：\r\n       普通IP通信是在一个发送者和一个接收者之间进行的，我们常把它称为点对点的通信，但对于有些应用，这种点对点的通信模式不能有效地满足实际应用的需求。例如：一个数字电话会议系统由多个会场组成，当在其中一个会场的参会人发言时，要求其它会场都能即时的得到此发言的内容，这是一个典型的一对多的通信应用，通常把这种一对多的通信称为多播通信。采用多播通信技术，不仅可以实现一个发送者和多个接收者之间进行通信的功能，而且可以有效减轻网络通信的负担，避免资源的无谓浪费。\r\n　\r\n　　广播也是一种实现一对多数据通信的模式，但广播与多播在实现方式上有所不同。\r\n\r\n      广播是将数据从一个工作站发出，局域网内的其他所有工作站都能收到它。这一特征适用于无连接协议，因为LAN上的所有机器都可获得并处理广播消息。使用广播消息的不利之处是每台机器都必须对该消息进行处理。\r\n\r\n      多播通信则不同，数据从一个工作站发出后，如果在其它LAN上的机器上面运行的进程表示对这些数据“有兴趣”，多播数据才会制给它们。\r\n\r\n     多播地址范围：224.0.0.0到239.255.255.255，但是很多是不能用的,例如:224.0.0.0是保留地址，具体的请自己查阅相关文档。。\r\n\r\n    要实现接受到多播消息，那么你就必须加入多播组，那么这个组内的成员发送的多播消息，你才能接受的到。WSAJoinLeaf就是实现这个功能的。\r\n\r\n实现：\r\n接受者：\r\n[cpp] view plaincopy\r\n#include <iostream>  \r\n#include <string>  \r\n#include <winsock2.h>  \r\n#pragma comment(lib,\"ws2_32.lib\")  \r\nusing namespace std;  \r\n  \r\n#define bufferSize 1024  \r\nvoid main()  \r\n{  \r\n    WORD wVersionRequested;  \r\n    WSADATA wsaData;  \r\n    int err;  \r\n    wVersionRequested = MAKEWORD( 2, 2 );  \r\n    err = WSAStartup( wVersionRequested, &wsaData );  \r\n    if ( err != 0 ) {               \r\n        return;  \r\n    }  \r\n    if ( LOBYTE( wsaData.wVersion ) != 2 ||  \r\n        HIBYTE( wsaData.wVersion ) != 2 ) {  \r\n            WSACleanup( );  \r\n            return;   \r\n    }  \r\n    SOCKET socket;  \r\n      \r\n    if((socket=WSASocket(AF_INET,SOCK_DGRAM,0,NULL,0,WSA_FLAG_MULTIPOINT_C_LEAF|  \r\n        WSA_FLAG_MULTIPOINT_D_LEAF|WSA_FLAG_OVERLAPPED))==INVALID_SOCKET)  \r\n    {  \r\n        cout<<\"socket failed with: \"<<WSAGetLastError()<<endl;  \r\n        WSACleanup();  \r\n        return;  \r\n    }  \r\n  \r\n    sockaddr_in localAddress;  \r\n    localAddress.sin_family=AF_INET;  \r\n    localAddress.sin_port=htons(2500);  \r\n  \r\n    localAddress.sin_addr.S_un.S_addr=INADDR_ANY;  \r\n  \r\n    int length=sizeof(localAddress);  \r\n    if(bind(socket,(sockaddr*)&localAddress,length)==SOCKET_ERROR)  \r\n    {  \r\n        cout<<\" 绑定失败:\"<<WSAGetLastError()<<endl;  \r\n        closesocket(socket);  \r\n        WSACleanup();  \r\n        return;  \r\n    }  \r\n  \r\n    sockaddr_in remoteAddress;  \r\n    remoteAddress.sin_family=AF_INET;  \r\n    remoteAddress.sin_port=htons(2500);  \r\n    remoteAddress.sin_addr.S_un.S_addr=inet_addr(\"233.0.0.1\");  \r\n  \r\n    SOCKET socket_join;  \r\n    if((socket_join=WSAJoinLeaf(socket,(const sockaddr*)&remoteAddress,sizeof(remoteAddress),NULL,NULL,NULL,  \r\n        NULL,JL_BOTH))==SOCKET_ERROR)  \r\n    {  \r\n        cout<<\"wsaJoinLeaf() failed: \"<<WSAGetLastError()<<endl;  \r\n        closesocket(socket);  \r\n        WSACleanup();  \r\n        return;  \r\n    }  \r\n  \r\n    char receiverBuf[bufferSize];  \r\n    sockaddr_in fromAddress;  \r\n    int len=sizeof(fromAddress);  \r\n    while (1)  \r\n    {  \r\n        int retCount;  \r\n        if((retCount=recvfrom(socket,receiverBuf,bufferSize,0,(sockaddr*)&fromAddress,&len))==SOCKET_ERROR)  \r\n        {  \r\n            cout<<\"recvfrom failed with:\"<<WSAGetLastError()<<endl;  \r\n            closesocket(socket_join);  \r\n            closesocket(socket);  \r\n            WSACleanup();  \r\n            return;  \r\n        }  \r\n        if (strcmp(receiverBuf,\"quit\")==0)  \r\n            break;  \r\n        else  \r\n        {  \r\n            receiverBuf[retCount]=\'\\0\';  \r\n            cout<<\"data:\"<<receiverBuf<<\'\\n\'<<\"from: \"<<inet_ntoa(fromAddress.sin_addr)<<endl;  \r\n        }  \r\n    }  \r\n    closesocket(socket_join);  \r\n    closesocket(socket);  \r\n    WSACleanup();  \r\n    return;  \r\n  \r\n}  \r\n加载winsock库版本等信息，初始化----->绑定到自己的IP端口------>加入多播组------>接受数据..\r\n\r\n\r\n发送者：\r\n[cpp] view plaincopy\r\n#include <iostream>  \r\n#include <string>  \r\n#include <winsock2.h>  \r\n#pragma comment(lib,\"ws2_32.lib\")  \r\nusing namespace std;  \r\n  \r\n#define bufferSize 1024  \r\nvoid main()  \r\n{  \r\n    WORD wVersionRequested;  \r\n    WSADATA wsaData;  \r\n    int err;  \r\n    wVersionRequested = MAKEWORD( 2, 2 );  \r\n    err = WSAStartup( wVersionRequested, &wsaData );  \r\n    if ( err != 0 ) {               \r\n        return;  \r\n    }  \r\n    if ( LOBYTE( wsaData.wVersion ) != 2 ||  \r\n        HIBYTE( wsaData.wVersion ) != 2 ) {  \r\n            WSACleanup( );  \r\n            return;   \r\n    }  \r\n    SOCKET socket;  \r\n  \r\n    if((socket=WSASocket(AF_INET,SOCK_DGRAM,0,NULL,0,WSA_FLAG_MULTIPOINT_C_LEAF|  \r\n        WSA_FLAG_MULTIPOINT_D_LEAF|WSA_FLAG_OVERLAPPED))==INVALID_SOCKET)  \r\n    {  \r\n        cout<<\"socket failed with: \"<<WSAGetLastError()<<endl;  \r\n        WSACleanup();  \r\n        return;  \r\n    }  \r\n  \r\n    sockaddr_in remoteAddress;  \r\n    remoteAddress.sin_family=AF_INET;  \r\n    remoteAddress.sin_port=htons(2500);  \r\n    remoteAddress.sin_addr.S_un.S_addr=inet_addr(\"233.0.0.1\");  \r\n  \r\n    SOCKET socket_join;  \r\n    if((socket_join=WSAJoinLeaf(socket,(const sockaddr*)&remoteAddress,sizeof(remoteAddress),NULL,NULL,NULL,  \r\n        NULL,JL_BOTH))==SOCKET_ERROR)  \r\n    {  \r\n        cout<<\"wsaJoinLeaf() failed: \"<<WSAGetLastError()<<endl;  \r\n        closesocket(socket);  \r\n        WSACleanup();  \r\n        return;  \r\n    }  \r\n  \r\n    char sendBuffer[bufferSize];  \r\n    while(1)  \r\n    {  \r\n        cout<<\"Send:  \";  \r\n        cin>>sendBuffer;  \r\n        if((sendto(socket,sendBuffer,strlen(sendBuffer),0,(sockaddr*)&remoteAddress,sizeof(remoteAddress)))==SOCKET_ERROR)  \r\n        {  \r\n            cout<<\"Sendto failed with: \"<<WSAGetLastError()<<endl;  \r\n            closesocket(socket_join);  \r\n            closesocket(socket);  \r\n            WSACleanup();  \r\n            return;  \r\n        }  \r\n        if(strcmp(sendBuffer,\"quit\")==0)  \r\n            break;  \r\n    }  \r\n    closesocket(socket);  \r\n    WSACleanup();  \r\n    return;  \r\n  \r\n}  \r\n \r\n\r\n由于是参考着网上的例子写的，目前没有两台机器在旁边，所以不能测试能不能成功发送接受消息，每次启动第二个exe就直接消失。。大家自己找两台测试看看。。','c4','a33'),(34,' Linux 文件操作——系统调用和标准I/O库','0','2013-08-19 00:18:00','2013-08-19 00:18:00','一、什么是文件\r\n\r\n在讲述文件操作之前，我们首先要知道什么是文件。看到这个问题你可能会感觉到可笑，因为对于用过计算机的人来说，文件是最简单不过的概念了，例如一个文本是一个文件，一个work文档是一个文件等。但是在Linux中，文件的概念还远不止于这些，在Linux中，一切（或几乎一切）都是文件。文件包括很多的内容，例如：大家知道的普通文件是文件，目录也是一个文件，设备也是一个文件，管道也是一个文件等等。对于目录、设备这些的操作也可以完全等同于对纯文本文件的操作，这也是Linux非常成功的特性之一吧。\r\n\r\n二、系统调用\r\n\r\n1、文件描述符\r\n文件描述符是一些小数值，你可以通过它们访问的打开的文件设备，而有多少文件描述符可用取决于系统的配置情况。但是当一个程序开始运行时，它一般会有3个已经打开的文件描述符，就是\r\n0：标准输入\r\n1：标准输出\r\n2：标准错误\r\n那些数学（即0、1、2）就是文件描述符，因为在Linux上一切都是文件，所以标准输入（stdin），标准输出（stdout）和标准错误（stderr）也可看作文件来对待。\r\n\r\n2、系统调用常用函数\r\n\r\nA、open系统调用\r\n\r\nopen函数的原型为：\r\nint open(const char *path, int oflags);\r\nint open(const char *path, int oflags, mode_t mode);\r\n\r\npath，是包括路径的完整文件名，oflags是文件访问模式（即是什么方式打开文件，只读、只写还是可读并可写等），mode用于设定文件的访问权限。具体的可选参数，可以自己查看手册页，这里不一一详述。\r\n\r\nopen建立了一条到文件或设备的访问路径，如果调用成功，返回一个可以被read、write等其他系统调用的函数使用的文件描述符，而且这个文件描述是唯一的，不与任何其他运行中的进程共享，在失败时返回-1，并设置全局变量errno来指明失明的原因。\r\n\r\nB、write系统调用\r\n\r\nwrite函数的原型为：\r\nsize_t write(int fildes, const void *buf, size_t nbytes);\r\n\r\nwrite的作用是把缓冲区buf的前nbytes个字节写入到文件描述符fildes关联的文件中，返回实际写入的字节数。返回0表示没有写入任何数据，返回-1表示调用中出现了错误，错误代码保存在errno中。\r\n\r\n注：fildes一定要是在open调用中返回的创建的文件描述符，或者是0、1、2等标准输入、输出或标准错误。\r\n\r\nC、read系统调用\r\n\r\nread函数的原型为：\r\nsize_t read(int fildes, void *buf, size_t nbytes);\r\n\r\nread系统调用的作用是从与文件描述符相关的文件里读入nbytes个字节的数据，并把它们放到数据区buf中，返回读入的字节数，失败时返回-1。\r\n\r\nD、close系统调用\r\n\r\nclose调用的函数原型为：\r\nint close(int fildes);\r\n\r\nclose函数的作用是终于文件描述符fildes一其对应的文件之间的关联。\r\n\r\n\r\nE、例子\r\n\r\n说了这么多，我就给出一个完整的例子吧，就是从一个数据文件（里面有1M个‘0’字符）逐个复制到别一个文件。文件名为copy_system.c，代码如下：\r\n[cpp] view plaincopyprint?\r\n#include <unistd.h>  \r\n#include <sys/stat.h>  \r\n#include <fcntl.h>  \r\n#include <stdlib.h>  \r\n  \r\nint main()  \r\n{  \r\n    char c = \'\\0\';  \r\n    int in = -1, out = -1;  \r\n      \r\n    //以只读方式打开数据文件  \r\n    in = open(\"Data.txt\", O_RDONLY);  \r\n    //以只写方式创建文件，如果文件不存在就创建一个新的文件  \r\n    //文件属主具有读和写的权限  \r\n    out = open(\"copy_system.out.txt\", O_WRONLY|O_CREAT, S_IRUSR|S_IWUSR);  \r\n    while(read(in, &c, 1) == 1)//读一个字节的数据  \r\n        write(out, &c, 1);//写一个字节的数据  \r\n  \r\n    //关闭文件描述符  \r\n    close(in);  \r\n    close(out);  \r\n    return 0;  \r\n}  \r\n\r\n\r\n三、标准I/O库\r\n有过C编程经历的人都会知道stdio头文件，它就是C语言的标准IO库，在标准IO库中，与底层文件描述符相对应的是流，它被实现为指向结构FILE的指针。IO库的函数有很多，为了与前面的内容对应，这里还是只讲与前面四个函数相对应的函数，其他的函数，你可以查一查手册页。\r\n\r\nA、fopen库函数\r\n\r\nfopen库函数的原型为：\r\nFILE* fopen(const char *filename, const char *mode);\r\n\r\n它与底层系统调用open类似，成功时返回一个非空指针。失败时返回NULL。\r\n\r\nB、fread库函数\r\n\r\nfread库函数的原型为：\r\nsize_t fread(void *ptr, size_t size, size_t nitems, FILE *stream);\r\n\r\n它与底层调用read相似，其作用是从stream读取nitems个长度为size的数据到ptr所指向的缓冲区中。返回值是成功读到缓冲区中的记录个数。\r\n\r\n注：stream为用fopen函数返回的文件结构指针。\r\n\r\nC、fwrite库函数\r\n\r\nfwrite库函数的原型：\r\nsize_t fwrite(const void *ptr, size_t size, size_t nitems, FILE *stream);\r\n\r\n它与底层调用write相似，其作用是从ptr指向的缓冲区中读取nitems个长度为size到数据，并把它们写到stream所对应的文件中。\r\n\r\nD、fclose库函数\r\n\r\nfclose库函数的原型为：\r\nint fclose(FILE *stream);\r\n\r\n它与系统调用close相似，其作用是关闭指定的文件流stream。\r\n\r\n例子\r\n同样地，下面是前一个例子的另一个实现版本，它实现的功能与先前的例子一样，不过使用的是标准I/O库，而不是系统调用，文件名为copy_stdio.c代码如下：\r\n[cpp] view plaincopyprint?\r\n#include <stdio.h>  \r\n#include <stdlib.h>  \r\n  \r\nint main()  \r\n{  \r\n    int c = 0;  \r\n    FILE *pfin = NULL;  \r\n    FILE *pfout = NULL;  \r\n  \r\n    //以只读方式打开数据文件  \r\n    pfin = fopen(\"Data.txt\", \"r\");  \r\n    //以只写方式打开复制的新文件  \r\n    pfout = fopen(\"copy_stdio.out.txt\", \"w\");  \r\n      \r\n    while(fread(&c, sizeof(char), 1, pfin))//读数据  \r\n        fwrite(&c, sizeof(char), 1, pfout);//写数据  \r\n    //关闭文件流  \r\n    fclose(pfin);  \r\n    fclose(pfout);  \r\n    return 0;  \r\n}  \r\n\r\n\r\n当然这里你也可以用其他的库函数来完成工作,如：用fgetc代替fread，用fputc代替fwrite等。\r\n\r\n四、文件描述符和文件流的关系\r\n每个文件流都对应一个底层文件描述符，你可以把底层输入输出操作与高层文件流操作混合使用，但是一般不要这样做，因为数据缓冲的后果难以预料。我们可以通过调用fileno函数（原型为：int fileno(FILE *stream))来确定文件流使用的底层文件描述符，它返回指向文件流的文件描述符。相反地，你可以通过调用函数fdopen（原型为FILE* fdopen(int fildes, const char* mode))来在一个已经打开的文件描述符上创建一个新的文件流，mode参数与fopen函数的完全一样，同时它必须符合该文件在最初打开时所设定的访问模式。\r\n\r\n但是在Linux下的编程，系统调用用得比较多一些，因为很多时候系统调用能提供更多的灵活性和更加强大的功能，有些操作是一定要使用系统调用，例如，创建文件读写锁时就一定要使用系统调用。\r\n\r\n五、系统调用与标准I/O的性能比较\r\n就拿本例子中的代码来比较，两个例子编译后生成的可执行文件的文件名分别为：copy_system.exe和copy_stdio.exe，在Linux下用time命令来测试其运行时间如下：\r\n\r\n\r\n\r\n从测试结果可以看出，系统调用的效率比库函数要低很多。为什么呢？\r\n\r\n因为使用系统调用会影响系统的性能。与函数调用相比，系统调用时，Linux必须从运行用户代码切换到执行内核代码，然后再返回用户代码，所以系统调用的开销要比普通函数调用大一些。然而也是有办法减少这种开销的，就是在程序中尽量减少系统调用的的次数，并且让每次系统调用完成尽量多的工作。\r\n\r\n而库函数为什么做同样的事情效率却会高这么多呢？这是因为库函数在数据满足数据块长度（或buffer长度）要求时才安排执行底层系统调用，从而减少了系统调用的次数，也让每次的系统调用做了尽量多的事情，所以效率就比较高。\r\n\r\n六、提高系统调用的简单方法举例\r\n用回每一个例子（coy_system.c）的代码，略加修改就能提高我们的效率，例如一次读1024个字节，修改后保存文件名为copy_system2.c，代码如下：\r\n\r\n[cpp] view plaincopyprint?\r\n#include <unistd.h>  \r\n#include <sys/stat.h>  \r\n#include <fcntl.h>  \r\n#include <stdlib.h>  \r\n  \r\nint main()  \r\n{  \r\n    char buff[1024];  \r\n    int in = -1, out = -1;  \r\n    int nread = 0;  \r\n  \r\n    in = open(\"Data.txt\", O_RDONLY);  \r\n    out = open(\"copy_system2.out.txt\", O_WRONLY|O_CREAT, S_IRUSR|S_IWUSR);  \r\n    //一次读写1024个字节  \r\n    while((nread = read(in, buff, sizeof(buff))) > 0)  \r\n        write(out, buff, nread);  \r\n  \r\n    close(in);  \r\n    close(out);  \r\n    return 0;  \r\n}  \r\n\r\n\r\n生成的可执行文件为copy_system2.exe，使用time命令查看其执行时间，如下：\r\n\r\n\r\n\r\n比较下可以看出，其性能改善了一个数量级，其效率甚至比用库函数一个一个字符复制来来得高效，至少在我的机子上是这样。','c7','a34');

/*Table structure for table `category` */

DROP TABLE IF EXISTS `category`;

CREATE TABLE `category` (
  `category_id` int(11) NOT NULL AUTO_INCREMENT COMMENT '分类ID',
  `category_name` varchar(255) NOT NULL COMMENT '分类名称',
  `category_adddate` datetime DEFAULT NULL COMMENT '分类添加时间',
  `category_alias` varchar(255) DEFAULT NULL COMMENT '分类别名',
  `category_moddate` datetime DEFAULT NULL COMMENT '分类修改时间',
  `category_url` varchar(1000) DEFAULT NULL COMMENT '分类URL',
  `category_uid` varchar(255) NOT NULL COMMENT '分类用的ID',
  `user_uid` varchar(255) NOT NULL,
  PRIMARY KEY (`category_id`)
) ENGINE=InnoDB AUTO_INCREMENT=8 DEFAULT CHARSET=utf8 CHECKSUM=1 DELAY_KEY_WRITE=1 ROW_FORMAT=DYNAMIC;

/*Data for the table `category` */

insert  into `category`(`category_id`,`category_name`,`category_adddate`,`category_alias`,`category_moddate`,`category_url`,`category_uid`,`user_uid`) values (0,'PHP',NULL,NULL,NULL,NULL,'c0','u1'),(1,'YII开发文档',NULL,NULL,NULL,NULL,'c1','u1'),(2,'设计模式',NULL,NULL,NULL,NULL,'c2','u1'),(3,'重构',NULL,NULL,NULL,NULL,'c3','u1'),(4,'java',NULL,NULL,NULL,NULL,'c4','u2'),(5,'c++',NULL,NULL,NULL,NULL,'c5','u2'),(6,'c',NULL,NULL,NULL,NULL,'c6','u3'),(7,'c#',NULL,NULL,NULL,NULL,'c7','u3');

/*Table structure for table `category_article` */

DROP TABLE IF EXISTS `category_article`;

/*!50001 DROP VIEW IF EXISTS `category_article` */;
/*!50001 DROP TABLE IF EXISTS `category_article` */;

/*!50001 CREATE TABLE `category_article` (
  `article_id` int(11) NOT NULL DEFAULT '0',
  `article_name` varchar(255) NOT NULL COMMENT 'article名称',
  `article_url` varchar(255) DEFAULT NULL,
  `article_adddate` datetime NOT NULL,
  `article_moddate` datetime DEFAULT NULL,
  `article_content` blob NOT NULL COMMENT 'article内容',
  `category_uid` varchar(255) NOT NULL,
  `article_uid` varchar(255) NOT NULL,
  `category_id` int(11) NOT NULL DEFAULT '0' COMMENT '分类ID',
  `category_name` varchar(255) NOT NULL COMMENT '分类名称',
  `category_adddate` datetime DEFAULT NULL COMMENT '分类添加时间',
  `category_moddate` datetime DEFAULT NULL COMMENT '分类修改时间',
  `category_alias` varchar(255) DEFAULT NULL COMMENT '分类别名',
  `category_url` varchar(1000) DEFAULT NULL COMMENT '分类URL',
  `user_uid` varchar(255) NOT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8 */;

/*Table structure for table `user_category` */

DROP TABLE IF EXISTS `user_category`;

/*!50001 DROP VIEW IF EXISTS `user_category` */;
/*!50001 DROP TABLE IF EXISTS `user_category` */;

/*!50001 CREATE TABLE `user_category` (
  `user_name` varchar(10) NOT NULL,
  `category_id` int(11) NOT NULL DEFAULT '0' COMMENT '分类ID',
  `category_name` varchar(255) NOT NULL COMMENT '分类名称',
  `category_adddate` datetime DEFAULT NULL COMMENT '分类添加时间',
  `category_alias` varchar(255) DEFAULT NULL COMMENT '分类别名',
  `category_moddate` datetime DEFAULT NULL COMMENT '分类修改时间',
  `category_url` varchar(1000) DEFAULT NULL COMMENT '分类URL',
  `category_uid` varchar(255) NOT NULL COMMENT '分类用的ID',
  `user_uid` varchar(255) NOT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8 */;

/*Table structure for table `users` */

DROP TABLE IF EXISTS `users`;

CREATE TABLE `users` (
  `user_id` int(32) NOT NULL AUTO_INCREMENT,
  `user_name` varchar(10) NOT NULL,
  `user_uid` varchar(255) DEFAULT NULL,
  PRIMARY KEY (`user_id`)
) ENGINE=InnoDB AUTO_INCREMENT=4 DEFAULT CHARSET=utf8 CHECKSUM=1 DELAY_KEY_WRITE=1 ROW_FORMAT=DYNAMIC;

/*Data for the table `users` */

insert  into `users`(`user_id`,`user_name`,`user_uid`) values (1,'lucy','u1'),(2,'lilei','u2'),(3,'daisy','u3');

/*View structure for view category_article */

/*!50001 DROP TABLE IF EXISTS `category_article` */;
/*!50001 DROP VIEW IF EXISTS `category_article` */;

/*!50001 CREATE ALGORITHM=UNDEFINED DEFINER=`root`@`localhost` SQL SECURITY DEFINER VIEW `category_article` AS (select `a`.`article_id` AS `article_id`,`a`.`article_name` AS `article_name`,`a`.`article_url` AS `article_url`,`a`.`article_adddate` AS `article_adddate`,`a`.`article_moddate` AS `article_moddate`,`a`.`article_content` AS `article_content`,`a`.`category_uid` AS `category_uid`,`a`.`article_uid` AS `article_uid`,`c`.`category_id` AS `category_id`,`c`.`category_name` AS `category_name`,`c`.`category_adddate` AS `category_adddate`,`c`.`category_moddate` AS `category_moddate`,`c`.`category_alias` AS `category_alias`,`c`.`category_url` AS `category_url`,`c`.`user_uid` AS `user_uid` from (`article` `a` join `category` `c`) where (`a`.`category_uid` = `c`.`category_uid`)) */;

/*View structure for view user_category */

/*!50001 DROP TABLE IF EXISTS `user_category` */;
/*!50001 DROP VIEW IF EXISTS `user_category` */;

/*!50001 CREATE ALGORITHM=UNDEFINED DEFINER=`root`@`localhost` SQL SECURITY DEFINER VIEW `user_category` AS (select `u`.`user_name` AS `user_name`,`c`.`category_id` AS `category_id`,`c`.`category_name` AS `category_name`,`c`.`category_adddate` AS `category_adddate`,`c`.`category_alias` AS `category_alias`,`c`.`category_moddate` AS `category_moddate`,`c`.`category_url` AS `category_url`,`c`.`category_uid` AS `category_uid`,`c`.`user_uid` AS `user_uid` from (`users` `u` join `category` `c`) where (`u`.`user_uid` = `c`.`user_uid`)) */;

/*!40101 SET SQL_MODE=@OLD_SQL_MODE */;
/*!40014 SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS */;
